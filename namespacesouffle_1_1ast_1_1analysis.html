<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>souffle: souffle::ast::analysis Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">souffle
   &#160;<span id="projectnumber">2.0.2-371-g6315b36</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesouffle.html">souffle</a></li><li class="navelem"><a class="el" href="namespacesouffle_1_1ast.html">ast</a></li><li class="navelem"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html">analysis</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">souffle::ast::analysis Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacesouffle_1_1ast_1_1analysis_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_algebraic_data_type.html">AlgebraicDataType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregates types using sums and products.  <a href="classsouffle_1_1ast_1_1analysis_1_1_algebraic_data_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1ast_1_1analysis_1_1all__type__factory.html">all_type_factory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory for computing sets of types covering all potential types.  <a href="structsouffle_1_1ast_1_1analysis_1_1all__type__factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_analysis.html">Analysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for a AST <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_analysis.html" title="Abstract class for a AST Analysis.">Analysis</a>.  <a href="classsouffle_1_1ast_1_1analysis_1_1_analysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_assignment.html">Assignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An assignment maps a list of variables to values of their respective property space.  <a href="classsouffle_1_1ast_1_1analysis_1_1_assignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_auxiliary_arity_analysis.html">AuxiliaryArityAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the auxiliary arity for relations.  <a href="classsouffle_1_1ast_1_1analysis_1_1_auxiliary_arity_analysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_clause_normalisation_analysis.html">ClauseNormalisationAnalysis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_component_lookup_analysis.html">ComponentLookupAnalysis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_constant_type.html">ConstantType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representing the type assigned to a constant.  <a href="classsouffle_1_1ast_1_1analysis_1_1_constant_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_constraint.html">Constraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic base class for constraints on variables.  <a href="classsouffle_1_1ast_1_1analysis_1_1_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_constraint_analysis.html">ConstraintAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_constraint_analysis.html" title="A base class for ConstraintAnalysis collecting constraints for an analysis by visiting every node of ...">ConstraintAnalysis</a> collecting constraints for an analysis by visiting every node of a given AST.  <a href="classsouffle_1_1ast_1_1analysis_1_1_constraint_analysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_constraint_analysis_var.html">ConstraintAnalysisVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable type to be utilized by AST constraint analysis.  <a href="structsouffle_1_1ast_1_1analysis_1_1_constraint_analysis_var.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_functor_analysis.html">FunctorAnalysis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_i_o_type_analysis.html">IOTypeAnalysis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_normalised_clause.html">NormalisedClause</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_polymorphic_objects_analysis.html">PolymorphicObjectsAnalysis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_precedence_graph_analysis.html">PrecedenceGraphAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_analysis.html" title="Abstract class for a AST Analysis.">Analysis</a> pass computing the precedence graph of the relations of the datalog progam.  <a href="classsouffle_1_1ast_1_1analysis_1_1_precedence_graph_analysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_primitive_type.html">PrimitiveType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_primitive_type.html" title="PrimitiveType = Number/Unsigned/Float/Symbol The class representing pre-built, concrete types.">PrimitiveType</a> = Number/Unsigned/Float/Symbol The class representing pre-built, concrete types.  <a href="classsouffle_1_1ast_1_1analysis_1_1_primitive_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_problem.html">Problem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A problem is a list of constraints for which a solution is desired.  <a href="classsouffle_1_1ast_1_1analysis_1_1_problem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_profile_use_analysis.html">ProfileUseAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_analysis.html" title="Abstract class for a AST Analysis.">Analysis</a> that loads profile data and has a profile query interface.  <a href="classsouffle_1_1ast_1_1analysis_1_1_profile_use_analysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1ast_1_1analysis_1_1property__space.html">property_space</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A MPL type for defining a property space.  <a href="structsouffle_1_1ast_1_1analysis_1_1property__space.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_record_type.html">RecordType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A record type combining a list of fields into a new, aggregated type.  <a href="structsouffle_1_1ast_1_1analysis_1_1_record_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_recursive_clauses_analysis.html">RecursiveClausesAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_analysis.html" title="Abstract class for a AST Analysis.">Analysis</a> pass identifying clauses which are recursive.  <a href="classsouffle_1_1ast_1_1analysis_1_1_recursive_clauses_analysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_redundant_relations_analysis.html">RedundantRelationsAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_analysis.html" title="Abstract class for a AST Analysis.">Analysis</a> pass identifying relations which do not contribute to the computation of the output relations.  <a href="classsouffle_1_1ast_1_1analysis_1_1_redundant_relations_analysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_relation_detail_cache_analysis.html">RelationDetailCacheAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_analysis.html" title="Abstract class for a AST Analysis.">Analysis</a> pass mapping identifiers with relations and clauses.  <a href="classsouffle_1_1ast_1_1analysis_1_1_relation_detail_cache_analysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_relation_schedule_analysis.html">RelationScheduleAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_analysis.html" title="Abstract class for a AST Analysis.">Analysis</a> pass computing a schedule for computing relations.  <a href="classsouffle_1_1ast_1_1analysis_1_1_relation_schedule_analysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_relation_schedule_analysis_step.html">RelationScheduleAnalysisStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single step in a relation schedule, consisting of the relations computed in the step and the relations that are no longer required at that step.  <a href="classsouffle_1_1ast_1_1analysis_1_1_relation_schedule_analysis_step.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_s_c_c_graph_analysis.html">SCCGraphAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_analysis.html" title="Abstract class for a AST Analysis.">Analysis</a> pass computing the strongly connected component (SCC) graph for the datalog program.  <a href="classsouffle_1_1ast_1_1analysis_1_1_s_c_c_graph_analysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1ast_1_1analysis_1_1set__property__space.html">set_property_space</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A property space for set-based properties based on sub-set lattices.  <a href="structsouffle_1_1ast_1_1analysis_1_1set__property__space.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1ast_1_1analysis_1_1sub__type.html">sub_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of a meet operation between sets of types computing the set of pair-wise greatest common subtypes.  <a href="structsouffle_1_1ast_1_1analysis_1_1sub__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_subset_type.html">SubsetType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type being a subset of another type.  <a href="classsouffle_1_1ast_1_1analysis_1_1_subset_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_sum_type_branches_analysis.html">SumTypeBranchesAnalysis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_topologically_sorted_s_c_c_graph_analysis.html">TopologicallySortedSCCGraphAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_analysis.html" title="Abstract class for a AST Analysis.">Analysis</a> pass computing a topologically sorted strongly connected component (SCC) graph.  <a href="classsouffle_1_1ast_1_1analysis_1_1_topologically_sorted_s_c_c_graph_analysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract base class for types to be covered within a type environment.  <a href="classsouffle_1_1ast_1_1analysis_1_1_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1ast_1_1analysis_1_1type__lattice.html">type_lattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type lattice forming the property space for the <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html" title="An abstract base class for types to be covered within a type environment.">Type</a> analysis.  <a href="structsouffle_1_1ast_1_1analysis_1_1type__lattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type_analysis.html">TypeAnalysis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type_binding.html">TypeBinding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that encapsulates std::map of types binding that comes from .init c = Comp&lt;MyType&gt; <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html" title="An abstract base class for types to be covered within a type environment.">Type</a> binding in this example would be T-&gt;MyType if the component code is .comp Comp&lt;T&gt; ...  <a href="classsouffle_1_1ast_1_1analysis_1_1_type_binding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type_constraints_analysis.html">TypeConstraintsAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_constraint.html" title="A generic base class for constraints on variables.">Constraint</a> analysis framework for types.  <a href="classsouffle_1_1ast_1_1analysis_1_1_type_constraints_analysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type_environment.html">TypeEnvironment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type environment is a set of types.  <a href="classsouffle_1_1ast_1_1analysis_1_1_type_environment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type_environment_analysis.html">TypeEnvironmentAnalysis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_type_set.html">TypeSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection to represent sets of types.  <a href="structsouffle_1_1ast_1_1analysis_1_1_type_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_type_visitor.html">TypeVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A visitor for Types.  <a href="structsouffle_1_1ast_1_1analysis_1_1_type_visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_union_type.html">UnionType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A union type combining a list of types into a new, aggregated type.  <a href="classsouffle_1_1ast_1_1analysis_1_1_union_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_variable.html">Variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable to be utilized within constraints to be handled by the constraint solver.  <a href="structsouffle_1_1ast_1_1analysis_1_1_variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_visit_once_type_visitor.html">VisitOnceTypeVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A visitor for types visiting each type only once (effectively breaking recursive cycles).  <a href="classsouffle_1_1ast_1_1analysis_1_1_visit_once_type_visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a456aa88ad6dbd15a932359fa758ce4af"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a456aa88ad6dbd15a932359fa758ce4af">TypeConstraint</a> = std::shared_ptr&lt; <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_constraint.html">Constraint</a>&lt; <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a1b1ecaed9c14b785760d185d1274a57b">TypeVar</a> &gt; &gt;</td></tr>
<tr class="memdesc:a456aa88ad6dbd15a932359fa758ce4af"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of the type of constraint to be utilized in the type analysis.  <a href="namespacesouffle_1_1ast_1_1analysis.html#a456aa88ad6dbd15a932359fa758ce4af">More...</a><br /></td></tr>
<tr class="separator:a456aa88ad6dbd15a932359fa758ce4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1ecaed9c14b785760d185d1274a57b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a1b1ecaed9c14b785760d185d1274a57b">TypeVar</a> = <a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_constraint_analysis_var.html">ConstraintAnalysisVar</a>&lt; <a class="el" href="structsouffle_1_1ast_1_1analysis_1_1type__lattice.html">type_lattice</a> &gt;</td></tr>
<tr class="memdesc:a1b1ecaed9c14b785760d185d1274a57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of the type of variable to be utilized in the type analysis.  <a href="namespacesouffle_1_1ast_1_1analysis.html#a1b1ecaed9c14b785760d185d1274a57b">More...</a><br /></td></tr>
<tr class="separator:a1b1ecaed9c14b785760d185d1274a57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a31d97aca50e40690287987996481844e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a31d97aca50e40690287987996481844e">areEquivalentTypes</a> (const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;a, const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:a31d97aca50e40690287987996481844e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two types are equivalent.  <a href="namespacesouffle_1_1ast_1_1analysis.html#a31d97aca50e40690287987996481844e">More...</a><br /></td></tr>
<tr class="separator:a31d97aca50e40690287987996481844e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa937ef5b2452a42f1f884003aae88bf0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#aa937ef5b2452a42f1f884003aae88bf0">findUniqueRelationName</a> (const <a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;program, std::string <a class="el" href="test_8h.html#a23755e76c150985b681df786a657fee7">base</a>)</td></tr>
<tr class="memdesc:aa937ef5b2452a42f1f884003aae88bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a new relation name.  <a href="namespacesouffle_1_1ast_1_1analysis.html#aa937ef5b2452a42f1f884003aae88bf0">More...</a><br /></td></tr>
<tr class="separator:aa937ef5b2452a42f1f884003aae88bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db4a30b81cfeab00fdbe334526fb30e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a9db4a30b81cfeab00fdbe334526fb30e">findUniqueVariableName</a> (const <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;clause, std::string <a class="el" href="test_8h.html#a23755e76c150985b681df786a657fee7">base</a>)</td></tr>
<tr class="memdesc:a9db4a30b81cfeab00fdbe334526fb30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a variable name using base to form a string like base1 Use this when you need to limit the scope of a variable to the inside of an aggregate.  <a href="namespacesouffle_1_1ast_1_1analysis.html#a9db4a30b81cfeab00fdbe334526fb30e">More...</a><br /></td></tr>
<tr class="separator:a9db4a30b81cfeab00fdbe334526fb30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b605f2d521905266c738460486e9eb"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a57b605f2d521905266c738460486e9eb">getBaseType</a> (const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> *type)</td></tr>
<tr class="separator:a57b605f2d521905266c738460486e9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1073ec3616e2b1e5628ef038ce21e975"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_type_set.html">TypeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a1073ec3616e2b1e5628ef038ce21e975">getGreatestCommonSubtypes</a> (const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;a, const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:a1073ec3616e2b1e5628ef038ce21e975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common sub types of the two given types.  <a href="namespacesouffle_1_1ast_1_1analysis.html#a1073ec3616e2b1e5628ef038ce21e975">More...</a><br /></td></tr>
<tr class="separator:a1073ec3616e2b1e5628ef038ce21e975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc26d8cdcf2fb0d65dcdf49c8f89639"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:abdc26d8cdcf2fb0d65dcdf49c8f89639"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_type_set.html">TypeSet</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#abdc26d8cdcf2fb0d65dcdf49c8f89639">getGreatestCommonSubtypes</a> (const Types &amp;... <a class="el" href="_component_instantiation_8cpp.html#aaa259cf5782448e1215a879c8f02d6d5">types</a>)</td></tr>
<tr class="memdesc:abdc26d8cdcf2fb0d65dcdf49c8f89639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common sub types of the given types.  <a href="namespacesouffle_1_1ast_1_1analysis.html#abdc26d8cdcf2fb0d65dcdf49c8f89639">More...</a><br /></td></tr>
<tr class="separator:abdc26d8cdcf2fb0d65dcdf49c8f89639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad414b7856462f5965f3bccb58832cd71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_type_set.html">TypeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#ad414b7856462f5965f3bccb58832cd71">getGreatestCommonSubtypes</a> (const <a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_type_set.html">TypeSet</a> &amp;a, const <a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_type_set.html">TypeSet</a> &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:ad414b7856462f5965f3bccb58832cd71"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of pair-wise greatest common sub types of the types in the two given sets.  <a href="namespacesouffle_1_1ast_1_1analysis.html#ad414b7856462f5965f3bccb58832cd71">More...</a><br /></td></tr>
<tr class="separator:ad414b7856462f5965f3bccb58832cd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7064cd29e2864629fdde203144fa975"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_type_set.html">TypeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#ae7064cd29e2864629fdde203144fa975">getGreatestCommonSubtypes</a> (const <a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_type_set.html">TypeSet</a> &amp;set)</td></tr>
<tr class="memdesc:ae7064cd29e2864629fdde203144fa975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common sub types of all the types in the given set.  <a href="namespacesouffle_1_1ast_1_1analysis.html#ae7064cd29e2864629fdde203144fa975">More...</a><br /></td></tr>
<tr class="separator:ae7064cd29e2864629fdde203144fa975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108a2d9570b44c655bf3165e8d8613d4"><td class="memItemLeft" align="right" valign="top">std::map&lt; const <a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> *, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a108a2d9570b44c655bf3165e8d8613d4">getGroundedTerms</a> (const <a class="el" href="classsouffle_1_1ast_1_1_translation_unit.html">TranslationUnit</a> &amp;tu, const <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;clause)</td></tr>
<tr class="memdesc:a108a2d9570b44c655bf3165e8d8613d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyse the given clause and computes for each contained argument whether it is a grounded value or not.  <a href="namespacesouffle_1_1ast_1_1analysis.html#a108a2d9570b44c655bf3165e8d8613d4">More...</a><br /></td></tr>
<tr class="separator:a108a2d9570b44c655bf3165e8d8613d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc7e3bf641dffe8a8dd0db3a8b44712"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#abbc7e3bf641dffe8a8dd0db3a8b44712">getInjectedVariables</a> (const <a class="el" href="classsouffle_1_1ast_1_1_translation_unit.html">TranslationUnit</a> &amp;tu, const <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;clause, const <a class="el" href="classsouffle_1_1ast_1_1_aggregator.html">Aggregator</a> &amp;aggregate)</td></tr>
<tr class="memdesc:abbc7e3bf641dffe8a8dd0db3a8b44712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an aggregate and a clause, we find all the variables that have been injected into the aggregate.  <a href="namespacesouffle_1_1ast_1_1analysis.html#abbc7e3bf641dffe8a8dd0db3a8b44712">More...</a><br /></td></tr>
<tr class="separator:abbc7e3bf641dffe8a8dd0db3a8b44712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1acc981f913d4ad9865fb655fe5e1f2"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#ac1acc981f913d4ad9865fb655fe5e1f2">getLocalVariables</a> (const <a class="el" href="classsouffle_1_1ast_1_1_translation_unit.html">TranslationUnit</a> &amp;tu, const <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;clause, const <a class="el" href="classsouffle_1_1ast_1_1_aggregator.html">Aggregator</a> &amp;aggregate)</td></tr>
<tr class="memdesc:ac1acc981f913d4ad9865fb655fe5e1f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the set of local variables in an aggregate expression.  <a href="namespacesouffle_1_1ast_1_1analysis.html#ac1acc981f913d4ad9865fb655fe5e1f2">More...</a><br /></td></tr>
<tr class="separator:ac1acc981f913d4ad9865fb655fe5e1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82279ed776db311a2251771a38f80dbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a82279ed776db311a2251771a38f80dbe">getTypeAttribute</a> (const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;type)</td></tr>
<tr class="separator:a82279ed776db311a2251771a38f80dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca099ea2c9cb2081b6295b0e58cc6e58"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#aca099ea2c9cb2081b6295b0e58cc6e58">getTypeAttribute</a> (const <a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_type_set.html">TypeSet</a> &amp;type)</td></tr>
<tr class="separator:aca099ea2c9cb2081b6295b0e58cc6e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa2c626b4878e0e5e1ae646ffdaa736"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a7aa2c626b4878e0e5e1ae646ffdaa736">getTypeQualifier</a> (const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;type)</td></tr>
<tr class="memdesc:a7aa2c626b4878e0e5e1ae646ffdaa736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns full type qualifier for a given type.  <a href="namespacesouffle_1_1ast_1_1analysis.html#a7aa2c626b4878e0e5e1ae646ffdaa736">More...</a><br /></td></tr>
<tr class="separator:a7aa2c626b4878e0e5e1ae646ffdaa736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e435338888fbb0a6cc096f1e699f637"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a2e435338888fbb0a6cc096f1e699f637">getVariablesOutsideAggregate</a> (const <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;clause, const <a class="el" href="classsouffle_1_1ast_1_1_aggregator.html">Aggregator</a> &amp;aggregate)</td></tr>
<tr class="memdesc:a2e435338888fbb0a6cc096f1e699f637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the set of variables occurring outside the aggregate.  <a href="namespacesouffle_1_1ast_1_1analysis.html#a2e435338888fbb0a6cc096f1e699f637">More...</a><br /></td></tr>
<tr class="separator:a2e435338888fbb0a6cc096f1e699f637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7dcac078836134ae4e1e59e4d3148e3"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#ac7dcac078836134ae4e1e59e4d3148e3">getWitnessVariables</a> (const <a class="el" href="classsouffle_1_1ast_1_1_translation_unit.html">TranslationUnit</a> &amp;tu, const <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;clause, const <a class="el" href="classsouffle_1_1ast_1_1_aggregator.html">Aggregator</a> &amp;aggregate)</td></tr>
<tr class="memdesc:ac7dcac078836134ae4e1e59e4d3148e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the set of witness variables that are used in the aggregate A variable is a witness if it occurs in the aggregate body (but not in an inner aggregate) and also occurs ungrounded in the outer scope.  <a href="namespacesouffle_1_1ast_1_1analysis.html#ac7dcac078836134ae4e1e59e4d3148e3">More...</a><br /></td></tr>
<tr class="separator:ac7dcac078836134ae4e1e59e4d3148e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ec4ec9ee27a1504619a34a39a59f28"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a456aa88ad6dbd15a932359fa758ce4af">TypeConstraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a09ec4ec9ee27a1504619a34a39a59f28">hasSuperTypeInSet</a> (const <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a1b1ecaed9c14b785760d185d1274a57b">TypeVar</a> &amp;var, <a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_type_set.html">TypeSet</a> values)</td></tr>
<tr class="memdesc:a09ec4ec9ee27a1504619a34a39a59f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constraint factory ensuring that all the types associated to the variable are subtypes of some type in the provided set (values)  <a href="namespacesouffle_1_1ast_1_1analysis.html#a09ec4ec9ee27a1504619a34a39a59f28">More...</a><br /></td></tr>
<tr class="separator:a09ec4ec9ee27a1504619a34a39a59f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884a05f7212028fe74129e203f6b370a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a884a05f7212028fe74129e203f6b370a">haveCommonSupertype</a> (const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;a, const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:a884a05f7212028fe74129e203f6b370a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if there exist a type t such that a &lt;: t and b &lt;: t.  <a href="namespacesouffle_1_1ast_1_1analysis.html#a884a05f7212028fe74129e203f6b370a">More...</a><br /></td></tr>
<tr class="separator:a884a05f7212028fe74129e203f6b370a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71cbd339532f57b3611b7b493ce127e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#ac71cbd339532f57b3611b7b493ce127e">isADTEnum</a> (const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_algebraic_data_type.html">AlgebraicDataType</a> &amp;type)</td></tr>
<tr class="memdesc:ac71cbd339532f57b3611b7b493ce127e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if ADT is enumerations (are all constructors empty)  <a href="namespacesouffle_1_1ast_1_1analysis.html#ac71cbd339532f57b3611b7b493ce127e">More...</a><br /></td></tr>
<tr class="separator:ac71cbd339532f57b3611b7b493ce127e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d30670b31997c7653fb61b7c073f1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#ab6d30670b31997c7653fb61b7c073f1b">isNumericType</a> (const <a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_type_set.html">TypeSet</a> &amp;type)</td></tr>
<tr class="separator:ab6d30670b31997c7653fb61b7c073f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c482b5c5fefb75d263667dbe6b1995"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a03c482b5c5fefb75d263667dbe6b1995">isOfKind</a> (const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;type, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a> kind)</td></tr>
<tr class="memdesc:a03c482b5c5fefb75d263667dbe6b1995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the type is of a kind corresponding to the <a class="el" href="class_type_attribute.html" title="Type attribute class.">TypeAttribute</a>.  <a href="namespacesouffle_1_1ast_1_1analysis.html#a03c482b5c5fefb75d263667dbe6b1995">More...</a><br /></td></tr>
<tr class="separator:a03c482b5c5fefb75d263667dbe6b1995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57035b21903488f1b7d1dbce08486cf5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a57035b21903488f1b7d1dbce08486cf5">isOfKind</a> (const <a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_type_set.html">TypeSet</a> &amp;typeSet, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a> kind)</td></tr>
<tr class="separator:a57035b21903488f1b7d1dbce08486cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0faa30c5f8af5d43f9b888018f7cc5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a3f0faa30c5f8af5d43f9b888018f7cc5">isOfRootType</a> (const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;type, const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;root)</td></tr>
<tr class="memdesc:a3f0faa30c5f8af5d43f9b888018f7cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given type is a sub-type of the given root type.  <a href="namespacesouffle_1_1ast_1_1analysis.html#a3f0faa30c5f8af5d43f9b888018f7cc5">More...</a><br /></td></tr>
<tr class="separator:a3f0faa30c5f8af5d43f9b888018f7cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16af0a5743a33b616da4f47bdd5bc56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#ac16af0a5743a33b616da4f47bdd5bc56">isOrderableType</a> (const <a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_type_set.html">TypeSet</a> &amp;type)</td></tr>
<tr class="separator:ac16af0a5743a33b616da4f47bdd5bc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a59a824c8f1a160e57decfc92341203"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a7a59a824c8f1a160e57decfc92341203">isSubtypeOf</a> (const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;a, const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:a7a59a824c8f1a160e57decfc92341203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether type a is a subtype of type b.  <a href="namespacesouffle_1_1ast_1_1analysis.html#a7a59a824c8f1a160e57decfc92341203">More...</a><br /></td></tr>
<tr class="separator:a7a59a824c8f1a160e57decfc92341203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf3d7f4bb24ba4705fc57759c922ab6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a456aa88ad6dbd15a932359fa758ce4af">TypeConstraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a0bf3d7f4bb24ba4705fc57759c922ab6">isSubtypeOf</a> (const <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a1b1ecaed9c14b785760d185d1274a57b">TypeVar</a> &amp;a, const <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a1b1ecaed9c14b785760d185d1274a57b">TypeVar</a> &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:a0bf3d7f4bb24ba4705fc57759c922ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constraint factory ensuring that all the types associated to the variable a are subtypes of the variable b.  <a href="namespacesouffle_1_1ast_1_1analysis.html#a0bf3d7f4bb24ba4705fc57759c922ab6">More...</a><br /></td></tr>
<tr class="separator:a0bf3d7f4bb24ba4705fc57759c922ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0992f547add4896b9f5e220c3d945449"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a456aa88ad6dbd15a932359fa758ce4af">TypeConstraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a0992f547add4896b9f5e220c3d945449">isSubtypeOf</a> (const <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a1b1ecaed9c14b785760d185d1274a57b">TypeVar</a> &amp;variable, const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;type)</td></tr>
<tr class="memdesc:a0992f547add4896b9f5e220c3d945449"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constraint factory ensuring that all the types associated to the variable a are subtypes of type b.  <a href="namespacesouffle_1_1ast_1_1analysis.html#a0992f547add4896b9f5e220c3d945449">More...</a><br /></td></tr>
<tr class="separator:a0992f547add4896b9f5e220c3d945449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749706946fac0387109eba3029f778bd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a456aa88ad6dbd15a932359fa758ce4af">TypeConstraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a749706946fac0387109eba3029f778bd">isSubtypeOfComponent</a> (const <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a1b1ecaed9c14b785760d185d1274a57b">TypeVar</a> &amp;elementVariable, const <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a1b1ecaed9c14b785760d185d1274a57b">TypeVar</a> &amp;recordVariable, size_t index)</td></tr>
<tr class="memdesc:a749706946fac0387109eba3029f778bd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_constraint.html" title="A generic base class for constraints on variables.">Constraint</a> on record type and its elements.  <a href="namespacesouffle_1_1ast_1_1analysis.html#a749706946fac0387109eba3029f778bd">More...</a><br /></td></tr>
<tr class="separator:a749706946fac0387109eba3029f778bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd84a9ac1ca23adad8d76e0b1ac4cc3d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a456aa88ad6dbd15a932359fa758ce4af">TypeConstraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#acd84a9ac1ca23adad8d76e0b1ac4cc3d">satisfiesOverload</a> (const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type_environment.html">TypeEnvironment</a> &amp;typeEnv, <a class="el" href="namespacesouffle.html#ab7b7797c4980b8080efdcecc75e684bc">IntrinsicFunctors</a> overloads, <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a1b1ecaed9c14b785760d185d1274a57b">TypeVar</a> result, std::vector&lt; <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a1b1ecaed9c14b785760d185d1274a57b">TypeVar</a> &gt; args, bool subtypeResult)</td></tr>
<tr class="memdesc:acd84a9ac1ca23adad8d76e0b1ac4cc3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of overloads, wait the list of candidates to reduce to one and then apply its constraints.  <a href="namespacesouffle_1_1ast_1_1analysis.html#acd84a9ac1ca23adad8d76e0b1ac4cc3d">More...</a><br /></td></tr>
<tr class="separator:acd84a9ac1ca23adad8d76e0b1ac4cc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc00ad3ca3158b1b85df24c67b10961"><td class="memTemplParams" colspan="2">template&lt;typename Var , typename Val  = typename Var::property_space::value_type&gt; </td></tr>
<tr class="memitem:a7fc00ad3ca3158b1b85df24c67b10961"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_constraint.html">Constraint</a>&lt; Var &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a7fc00ad3ca3158b1b85df24c67b10961">sub</a> (const Val &amp;a, const Var &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, const std::string &amp;symbol=&quot;&quot;)</td></tr>
<tr class="memdesc:a7fc00ad3ca3158b1b85df24c67b10961"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic factory for constraints of the form.  <a href="namespacesouffle_1_1ast_1_1analysis.html#a7fc00ad3ca3158b1b85df24c67b10961">More...</a><br /></td></tr>
<tr class="separator:a7fc00ad3ca3158b1b85df24c67b10961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af454c8b25ece926ca5206774d8f23be1"><td class="memTemplParams" colspan="2">template&lt;typename Var &gt; </td></tr>
<tr class="memitem:af454c8b25ece926ca5206774d8f23be1"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_constraint.html">Constraint</a>&lt; Var &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#af454c8b25ece926ca5206774d8f23be1">sub</a> (const Var &amp;a, const Var &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, const std::string &amp;symbol=&quot;&quot;)</td></tr>
<tr class="memdesc:af454c8b25ece926ca5206774d8f23be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic factory for constraints of the form.  <a href="namespacesouffle_1_1ast_1_1analysis.html#af454c8b25ece926ca5206774d8f23be1">More...</a><br /></td></tr>
<tr class="separator:af454c8b25ece926ca5206774d8f23be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb6a5b6fc9b260aee7e0989cd638fa8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a456aa88ad6dbd15a932359fa758ce4af">TypeConstraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a9eb6a5b6fc9b260aee7e0989cd638fa8">subtypesOfTheSameBaseType</a> (const <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a1b1ecaed9c14b785760d185d1274a57b">TypeVar</a> &amp;left, const <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a1b1ecaed9c14b785760d185d1274a57b">TypeVar</a> &amp;right)</td></tr>
<tr class="memdesc:a9eb6a5b6fc9b260aee7e0989cd638fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that types of left and right have the same base types.  <a href="namespacesouffle_1_1ast_1_1analysis.html#a9eb6a5b6fc9b260aee7e0989cd638fa8">More...</a><br /></td></tr>
<tr class="separator:a9eb6a5b6fc9b260aee7e0989cd638fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a456aa88ad6dbd15a932359fa758ce4af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456aa88ad6dbd15a932359fa758ce4af">&#9670;&nbsp;</a></span>TypeConstraint</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a456aa88ad6dbd15a932359fa758ce4af">souffle::ast::analysis::TypeConstraint</a> = typedef std::shared_ptr&lt;<a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_constraint.html">Constraint</a>&lt;<a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a1b1ecaed9c14b785760d185d1274a57b">TypeVar</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The definition of the type of constraint to be utilized in the type analysis. </p>

<p class="definition">Definition at line <a class="el" href="_type_constraints_8h_source.html#l00075">75</a> of file <a class="el" href="_type_constraints_8h_source.html">TypeConstraints.h</a>.</p>

</div>
</div>
<a id="a1b1ecaed9c14b785760d185d1274a57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1ecaed9c14b785760d185d1274a57b">&#9670;&nbsp;</a></span>TypeVar</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a1b1ecaed9c14b785760d185d1274a57b">souffle::ast::analysis::TypeVar</a> = typedef <a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_constraint_analysis_var.html">ConstraintAnalysisVar</a>&lt;<a class="el" href="structsouffle_1_1ast_1_1analysis_1_1type__lattice.html">type_lattice</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The definition of the type of variable to be utilized in the type analysis. </p>

<p class="definition">Definition at line <a class="el" href="_type_constraints_8h_source.html#l00072">72</a> of file <a class="el" href="_type_constraints_8h_source.html">TypeConstraints.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a31d97aca50e40690287987996481844e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d97aca50e40690287987996481844e">&#9670;&nbsp;</a></span>areEquivalentTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::ast::analysis::areEquivalentTypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if two types are equivalent. </p>
<p>That is, check if a &lt;: b and b &lt;: a </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00373">373</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

</div>
</div>
<a id="aa937ef5b2452a42f1f884003aae88bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa937ef5b2452a42f1f884003aae88bf0">&#9670;&nbsp;</a></span>findUniqueRelationName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::ast::analysis::findUniqueRelationName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a new relation name. </p>
<p>I use this when I create new relations either for aggregate bodies or singleton aggregates. </p>

<p class="definition">Definition at line <a class="el" href="_aggregate_8cpp_source.html#l00190">190</a> of file <a class="el" href="_aggregate_8cpp_source.html">Aggregate.cpp</a>.</p>

</div>
</div>
<a id="a9db4a30b81cfeab00fdbe334526fb30e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db4a30b81cfeab00fdbe334526fb30e">&#9670;&nbsp;</a></span>findUniqueVariableName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::ast::analysis::findUniqueVariableName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;&#160;</td>
          <td class="paramname"><em>clause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a variable name using base to form a string like base1 Use this when you need to limit the scope of a variable to the inside of an aggregate. </p>

<p class="definition">Definition at line <a class="el" href="_aggregate_8cpp_source.html#l00179">179</a> of file <a class="el" href="_aggregate_8cpp_source.html">Aggregate.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;                                                                         {</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    <span class="keywordtype">int</span> counter = 0;</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    <span class="keyword">auto</span> candidate = <a class="code" href="_reader_8h.html#a4ce824b383e7379148b61ee135baac5a">base</a>;</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    <span class="keywordflow">while</span> (<a class="code" href="namespacesouffle_1_1ast.html#af59ed6a7c649aec10999baea2f2c8b35">getRelation</a>(program, candidate) != <span class="keyword">nullptr</span>) {</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;        candidate = <a class="code" href="_reader_8h.html#a4ce824b383e7379148b61ee135baac5a">base</a> + <a class="code" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a>(counter++);</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_simplify_aggregate_target_expression_8cpp_source.html#l00029">souffle::ast::transform::SimplifyAggregateTargetExpressionTransformer::transform()</a>.</p>

</div>
</div>
<a id="a57b605f2d521905266c738460486e9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b605f2d521905266c738460486e9eb">&#9670;&nbsp;</a></span>getBaseType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a>&amp; souffle::ast::analysis::getBaseType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_constraints_8cpp_source.html#l00118">118</a> of file <a class="el" href="_type_constraints_8cpp_source.html">TypeConstraints.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;                                                                                           {</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1073ec3616e2b1e5628ef038ce21e975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1073ec3616e2b1e5628ef038ce21e975">&#9670;&nbsp;</a></span>getGreatestCommonSubtypes() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_type_set.html">TypeSet</a> souffle::ast::analysis::getGreatestCommonSubtypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the greatest common sub types of the two given types. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00254">254</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;                           {</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;        <span class="keywordflow">return</span> TypeSet(<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>);</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;    }</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160; </div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;    TypeSet res;</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;    <span class="keywordflow">if</span> (isA&lt;UnionType&gt;(a) &amp;&amp; isA&lt;UnionType&gt;(<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)) {</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;        <span class="comment">// collect common sub-types of union types</span></div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;        <span class="keyword">struct </span>collector : <span class="keyword">public</span> TypeVisitor&lt;void&gt; {</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;            <span class="keyword">const</span> Type&amp; <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>;</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;            TypeSet&amp; res;</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;            collector(<span class="keyword">const</span> Type&amp; <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, TypeSet&amp; res) : <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>(<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>), res(res) {}</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160; </div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;            <span class="keywordtype">void</span> visit(<span class="keyword">const</span> Type&amp; <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a7a59a824c8f1a160e57decfc92341203">isSubtypeOf</a>(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>, <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)) {</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;                    res.insert(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>);</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;                    TypeVisitor&lt;void&gt;::visit(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>);</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;                }</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;            }</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;            <span class="keywordtype">void</span> visitUnionType(<span class="keyword">const</span> UnionType&amp; <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; cur : <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>.getElementTypes()) {</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;                    visit(*cur);</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;                }</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;            }</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;        };</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160; </div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;        <span class="comment">// collect all common sub-types</span></div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;        collector(<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, res).visit(a);</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    }</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160; </div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    <span class="comment">// otherwise there is no common super type</span></div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;}</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160; </div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;TypeSet <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#ad414b7856462f5965f3bccb58832cd71">getGreatestCommonSubtypes</a>(<span class="keyword">const</span> TypeSet&amp; set) {</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;    <span class="comment">// Edge cases.</span></div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;    <span class="keywordflow">if</span> (set.empty() || set.isAll()) {</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        <span class="keywordflow">return</span> TypeSet();</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_type_system_8cpp_source.html#l00295">getGreatestCommonSubtypes()</a>.</p>

</div>
</div>
<a id="abdc26d8cdcf2fb0d65dcdf49c8f89639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc26d8cdcf2fb0d65dcdf49c8f89639">&#9670;&nbsp;</a></span>getGreatestCommonSubtypes() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_type_set.html">TypeSet</a> souffle::ast::analysis::getGreatestCommonSubtypes </td>
          <td>(</td>
          <td class="paramtype">const Types &amp;...&#160;</td>
          <td class="paramname"><em>types</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the greatest common sub types of the given types. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8h_source.html#l00542">542</a> of file <a class="el" href="_type_system_8h_source.html">TypeSystem.h</a>.</p>

</div>
</div>
<a id="ad414b7856462f5965f3bccb58832cd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad414b7856462f5965f3bccb58832cd71">&#9670;&nbsp;</a></span>getGreatestCommonSubtypes() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_type_set.html">TypeSet</a> souffle::ast::analysis::getGreatestCommonSubtypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_type_set.html">TypeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_type_set.html">TypeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The set of pair-wise greatest common sub types of the types in the two given sets. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00311">311</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;                   {</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>;</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    }</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>.isAll()) {</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;        <span class="keywordflow">return</span> a;</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;    }</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160; </div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    <span class="comment">// compute pairwise greatest common sub types</span></div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    TypeSet res;</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> Type&amp; x : a) {</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> Type&amp; y : <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>) {</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;            res.insert(<a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#ad414b7856462f5965f3bccb58832cd71">getGreatestCommonSubtypes</a>(x, y));</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;        }</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;    }</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;}</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160; </div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;<span class="keywordtype">bool</span> <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a884a05f7212028fe74129e203f6b370a">haveCommonSupertype</a>(<span class="keyword">const</span> Type&amp; a, <span class="keyword">const</span> Type&amp; <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>) {</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    assert(&amp;a.getTypeEnvironment() == &amp;<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>.getTypeEnvironment() &amp;&amp;</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;            <span class="stringliteral">&quot;Types must be in the same type environment&quot;</span>);</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160; </div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    <span class="keywordflow">if</span> (a == <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>) {</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae7064cd29e2864629fdde203144fa975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7064cd29e2864629fdde203144fa975">&#9670;&nbsp;</a></span>getGreatestCommonSubtypes() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_type_set.html">TypeSet</a> souffle::ast::analysis::getGreatestCommonSubtypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_type_set.html">TypeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the greatest common sub types of all the types in the given set. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00295">295</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;                    : set) {</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;        greatestCommonSubtypes = <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#ad414b7856462f5965f3bccb58832cd71">getGreatestCommonSubtypes</a>(TypeSet(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>), greatestCommonSubtypes);</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    }</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160; </div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    <span class="keywordflow">return</span> greatestCommonSubtypes;</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;}</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160; </div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;TypeSet <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#ad414b7856462f5965f3bccb58832cd71">getGreatestCommonSubtypes</a>(<span class="keyword">const</span> TypeSet&amp; a, <span class="keyword">const</span> TypeSet&amp; <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>) {</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;    <span class="comment">// special cases</span></div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;    <span class="keywordflow">if</span> (a.empty()) {</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;        <span class="keywordflow">return</span> a;</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_type_system_8cpp_source.html#l00254">getGreatestCommonSubtypes()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_1_1ast_1_1analysis_ae7064cd29e2864629fdde203144fa975_cgraph.png" border="0" usemap="#namespacesouffle_1_1ast_1_1analysis_ae7064cd29e2864629fdde203144fa975_cgraph" alt=""/></div>
<map name="namespacesouffle_1_1ast_1_1analysis_ae7064cd29e2864629fdde203144fa975_cgraph" id="namespacesouffle_1_1ast_1_1analysis_ae7064cd29e2864629fdde203144fa975_cgraph">
<area shape="rect" title="Computes the greatest common sub types of all the types in the given set." alt="" coords="5,5,232,47"/>
<area shape="rect" href="namespacesouffle_1_1ast_1_1analysis.html#a1073ec3616e2b1e5628ef038ce21e975" title="Computes the greatest common sub types of the two given types." alt="" coords="280,5,507,47"/>
</map>
</div>

</div>
</div>
<a id="a108a2d9570b44c655bf3165e8d8613d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108a2d9570b44c655bf3165e8d8613d4">&#9670;&nbsp;</a></span>getGroundedTerms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; const <a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> *, bool &gt; souffle::ast::analysis::getGroundedTerms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_translation_unit.html">TranslationUnit</a> &amp;&#160;</td>
          <td class="paramname"><em>tu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;&#160;</td>
          <td class="paramname"><em>clause</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyse the given clause and computes for each contained argument whether it is a grounded value or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tu</td><td>the translation unit containing the clause </td></tr>
    <tr><td class="paramname">clause</td><td>the clause to be analyzed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a map mapping each contained argument to a boolean indicating whether the argument represents a grounded value or not </dd></dl>

<p class="definition">Definition at line <a class="el" href="_ground_8cpp_source.html#l00278">278</a> of file <a class="el" href="_ground_8cpp_source.html">Ground.cpp</a>.</p>

</div>
</div>
<a id="abbc7e3bf641dffe8a8dd0db3a8b44712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc7e3bf641dffe8a8dd0db3a8b44712">&#9670;&nbsp;</a></span>getInjectedVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; std::string &gt; souffle::ast::analysis::getInjectedVariables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_translation_unit.html">TranslationUnit</a> &amp;&#160;</td>
          <td class="paramname"><em>tu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;&#160;</td>
          <td class="paramname"><em>clause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_aggregator.html">Aggregator</a> &amp;&#160;</td>
          <td class="paramname"><em>aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an aggregate and a clause, we find all the variables that have been injected into the aggregate. </p>
<p>This means that the variable occurs grounded in an outer scope. BUT does not occur in the target expression.</p>
<p>This means that the variable occurs grounded in an outer scope. </p>
<p>Imagine we have this:</p>
<p>A(letter, x) :- a(letter, _), x = min y : { a(l, y), y &lt; max y : { a(letter, y) } }, z = max y : {B(y) }.</p>
<p>We need to figure out the base literal in which this aggregate occurs, so that we don't delete them Other aggregates occurring in the rule are irrelevant, so we'll replace the aggregate with a dummy aggregate variable. Then after that,</p>
<ol type="1">
<li>A(letter, x) :- a(letter, _), x = min y : { a(l, y), y &lt; max y : { a(letter, y) } }, z = aggr_var_0.</li>
</ol>
<p>We should also ground all the aggr_vars so that this grounding transfers to whatever variable they might be assigned to.</p>
<p>A(letter, x) :- a(letter, _), x = min y : { a(l, y), y &lt; max y : { a(letter, y) } }, z = aggr_var_0, grounding_atom(aggr_var_0).</p>
<p>Remember to negate the head atom and add it to the body. The clause we deal with will have a dummy head (*())</p>
<p>*() :- !A(letter, x), a(letter, _), x = min y : { a(l, y), y &lt; max y : { a(letter, y) } }, z = aggr_var_0, grounding_atom(aggr_var_0).</p>
<p>Replace the original aggregate with the same shit because we can't be counting local variables n shit</p>
<p>*() :- !A(letter, x), a(letter, _), x = min y : { a(l, y), y &lt; aggr_var_1 } }, z = aggr_var_0, grounding_atom(aggr_var_0).</p>
<p>Now, as long as we recorded all of the variables that occurred inside the aggregate, the intersection of these two sets (variables in an outer scope) and (variables occurring in t</p>
<p>A variable is considered <em>injected</em> into an aggregate if it occurs both within the aggregate AS WELL AS <em>grounded</em> in the outer scope. An outer scope could be an outer aggregate, or also just the base/rule scope. (i.e. not inside of another aggregate that is not an ancestor of this one).</p>
<p>So then in order to calculate the set of variables that have been injected into an aggregate, we perform the following steps:</p>
<ol type="1">
<li>Find the set of variables occurring within the aggregate "aggregate"</li>
<li>Find the set of variables that occur grounded in the outside scope 2a. Replace all non-ancestral aggregates with variables so that we can ignore their variable contents (it is not relevant). 2b. Replace the target aggregate with a variable as well 2c. Ground all occurrences of the non-ancestral aggregate variable replacements (i.e. grounding_atom(+aggr_var_0)) 2d. Visit all variables occurring in this tweaked clause that we made from steps 2a-2c, and check if they are grounded, and also occur in the set of target aggregate variables. Then it is an injected variable.</li>
</ol>

<p class="definition">Definition at line <a class="el" href="_aggregate_8cpp_source.html#l00205">205</a> of file <a class="el" href="_aggregate_8cpp_source.html">Aggregate.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;                       : { a(<a class="code" href="html_js_chartist_min_8h.html#ae5e71a2600e8891c54854be157cc6626">l</a>, y),</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;     *       y &lt; max y : { a(letter, y) } },</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;     *       z = max y : {B(y) }.</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;     *</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;     *   We need to figure out the <a class="code" href="_reader_8h.html#a4ce824b383e7379148b61ee135baac5a">base</a> literal in <a class="code" href="namespacesouffle.html#a6e9757564e85959db8b14a9be7d544e1">which</a> <span class="keyword">this</span> aggregate occurs,</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;     *   so that we don<span class="stringliteral">&#39;t delete them</span></div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;<span class="stringliteral">     *   Other aggregates occurring in the rule are irrelevant, so we&#39;</span>ll replace</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;     *   the aggregate with a dummy aggregate variable. Then after that,</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;     *</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;     *   2. A(letter, x) :-</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;     *       a(letter, _),</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;     *       x = min y : { a(<a class="code" href="html_js_chartist_min_8h.html#ae5e71a2600e8891c54854be157cc6626">l</a>, y),</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;     *       y &lt; max y : { a(letter, y) } },</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;     *       z = aggr_var_0.</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;     *</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;     *   We should also ground all the aggr_vars so that <span class="keyword">this</span> grounding</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;     *   transfers to whatever variable they might be assigned to.</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;     *</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;     *   A(letter, x) :-</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;     *       a(letter, _),</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;     *       x = min y : { a(<a class="code" href="html_js_chartist_min_8h.html#ae5e71a2600e8891c54854be157cc6626">l</a>, y),</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;     *       y &lt; max y : { a(letter, y) } },</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;     *       z = aggr_var_0,</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;     *       grounding_atom(aggr_var_0).</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;     *</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;     *   Remember to negate the head atom and add it to the body. The clause we deal with will have a</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;     *   dummy head (*())</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;     *</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;     *    *() :- !A(letter, x), a(letter, _), x = min y : { a(<a class="code" href="html_js_chartist_min_8h.html#ae5e71a2600e8891c54854be157cc6626">l</a>, y), y &lt; max y : { a(letter, y) } },</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;     *        z = aggr_var_0, grounding_atom(aggr_var_0).</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;     *</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;     *   Replace the original aggregate with the same shit because we can<span class="stringliteral">&#39;t be counting local variables n shit</span></div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;<span class="stringliteral">     *</span></div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;<span class="stringliteral">     *    *() :- !A(letter, x), a(letter, _), x = min y : { a(l, y), y &lt; aggr_var_1 } }, z = aggr_var_0,</span></div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;<span class="stringliteral">     *        grounding_atom(aggr_var_0).</span></div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;<span class="stringliteral">     *</span></div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;<span class="stringliteral">     *   Now, as long as we recorded all of the variables that occurred inside the aggregate, the intersection</span></div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;<span class="stringliteral">     *   of these two sets (variables in an outer scope) and (variables occurring in t</span></div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;<span class="stringliteral">     **/</span></div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;<span class="stringliteral"></span><span class="comment"></span> </div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;<span class="comment">    /**</span></div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;<span class="comment">     * A variable is considered *injected* into an aggregate if it occurs both within the aggregate AS WELL</span></div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;<span class="comment">     * AS *grounded* in the outer scope. An outer scope could be an outer aggregate, or also just the</span></div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;<span class="comment">     *base/rule scope. (i.e. not inside of another aggregate that is not an ancestor of this one).</span></div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;<span class="comment">     *</span></div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;<span class="comment">     *   So then in order to calculate the set of variables that have been injected into an aggregate, we</span></div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;<span class="comment">     * perform the following steps:</span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;<span class="comment">     *</span></div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;<span class="comment">     *   1. Find the set of variables occurring within the aggregate &quot;aggregate&quot;</span></div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;<span class="comment">     *   2. Find the set of variables that occur grounded in the outside scope</span></div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;<span class="comment">     *       2a. Replace all non-ancestral aggregates with variables so that we can ignore their variable</span></div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;<span class="comment">     * contents (it is not relevant). 2b. Replace the target aggregate with a variable as well 2c. Ground all</span></div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;<span class="comment">     * occurrences of the non-ancestral aggregate variable replacements (i.e. grounding_atom(+aggr_var_0)) 2d.</span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;<span class="comment">     * Visit all variables occurring in this tweaked clause that we made from steps 2a-2c, and check if they</span></div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;<span class="comment">     * are grounded, and also occur in the set of target aggregate variables. Then it is an injected variable.</span></div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;<span class="comment">     **/</span></div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;    // Step 1</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;    std::set&lt;std::string&gt; variablesInTargetAggregate;</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    visitDepthFirst(aggregate,</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;            [&amp;](const Variable&amp; variable) { variablesInTargetAggregate.insert(variable.getName()); });</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160; </div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;    std::set&lt;Own&lt;Aggregator&gt;&gt; ancestorAggregates;</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160; </div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;    visitDepthFirst(clause, [&amp;](const Aggregator&amp; ancestor) {</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;        visitDepthFirst(ancestor, [&amp;](const Aggregator&amp; agg) {</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;            if (agg == aggregate) {</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;                ancestorAggregates.insert(souffle::clone(&amp;ancestor));</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;            }</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;        });</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;    });</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160; </div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;    // 1. Replace non-ancestral aggregates with variables</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;    struct ReplaceAggregatesWithVariables : public NodeMapper {</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;        // Variables introduced to replace aggregators</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;        mutable std::set&lt;std::string&gt; aggregatorVariables;</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;        // ancestors are never replaced so don&#39;t need to <a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">clone</a>, but actually</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;        <span class="comment">// it will have a child that will become invalid at one point. This is a concern. Need to clone these</span></div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;        <span class="comment">// bastards too.</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;        std::set&lt;Own&lt;Aggregator&gt;&gt; ancestors;</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;        <span class="comment">// make sure you clone the agg first.</span></div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;        Own&lt;Aggregator&gt; targetAggregate;</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160; </div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;        <span class="keyword">const</span> std::set&lt;std::string&gt;&amp; getAggregatorVariables() {</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;            <span class="keywordflow">return</span> aggregatorVariables;</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        }</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160; </div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        ReplaceAggregatesWithVariables(std::set&lt;Own&lt;Aggregator&gt;&gt; ancestors, Own&lt;Aggregator&gt; targetAggregate)</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;                : ancestors(<a class="code" href="namespacestd.html">std</a>::move(ancestors)), targetAggregate(<a class="code" href="namespacestd.html">std</a>::move(targetAggregate)) {}</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160; </div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;        std::unique_ptr&lt;Node&gt; operator()(std::unique_ptr&lt;Node&gt; node)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;            <span class="keyword">static</span> <span class="keywordtype">int</span> numReplaced = 0;</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;            <span class="keywordflow">if</span> (<span class="keyword">auto</span>* aggregate = <span class="keyword">dynamic_cast&lt;</span>Aggregator*<span class="keyword">&gt;</span>(node.get())) {</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;                <span class="comment">// If we come across an aggregate that is NOT an ancestor of</span></div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;                <span class="comment">// the target aggregate, or that IS itself the target aggregate,</span></div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;                <span class="comment">// we should replace it with a dummy variable.</span></div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;                <span class="keywordtype">bool</span> isAncestor = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; ancestor : ancestors) {</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;                    <span class="keywordflow">if</span> (*ancestor == *aggregate) {</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;                        isAncestor = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;                    }</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;                }</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;                <span class="keywordflow">if</span> (!isAncestor || *aggregate == *targetAggregate) {</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;                    <span class="comment">// Replace the aggregator with a variable</span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;                    std::stringstream newVariableName;</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;                    newVariableName &lt;&lt; <span class="stringliteral">&quot;+aggr_var_&quot;</span> &lt;&lt; numReplaced++;</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;                    <span class="comment">// Keep track of which variables are bound to aggregators</span></div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;                    <span class="comment">// (only applicable to non-ancestral aggregates)</span></div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;                    <span class="keywordflow">if</span> (!isAncestor) {</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;                        <span class="comment">// we don&#39;t want to ground the target aggregate</span></div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;                        <span class="comment">// (why?) because these variables could be injected</span></div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;                        <span class="comment">// and that is fine.</span></div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;                        aggregatorVariables.insert(newVariableName.str());</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;                        <span class="comment">// but we are not supposed to be judging the aggregate as grounded and injected into</span></div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;                        <span class="comment">// the aggregate, that wouldn&#39;t make sense</span></div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;                    }</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;                    <span class="keywordflow">return</span> mk&lt;Variable&gt;(newVariableName.str());</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;                }</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;            }</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;            node-&gt;apply(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;            <span class="keywordflow">return</span> node;</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;        }</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    };</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    <span class="comment">// 2. make a clone of the clause and then apply that mapper onto it</span></div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    <span class="keyword">auto</span> clauseCopy = <a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a>(&amp;clause);</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;    <span class="keyword">auto</span> tweakedClause = mk&lt;Clause&gt;();</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    <span class="comment">// put a fake head here</span></div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    tweakedClause-&gt;setHead(mk&lt;Atom&gt;(<span class="stringliteral">&quot;*&quot;</span>));</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    <span class="comment">// copy in all the old body literals</span></div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    <span class="keywordflow">for</span> (Literal* lit : clause.getBodyLiterals()) {</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;        tweakedClause-&gt;addToBody(<a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a>(lit));</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;    }</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    <span class="comment">// copy in the head as a negated atom</span></div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;    tweakedClause-&gt;addToBody(mk&lt;Negation&gt;(<a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a>(clause.getHead())));</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    <span class="comment">// copy in body literals and also add the old head as a negated atom</span></div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    ReplaceAggregatesWithVariables update(std::move(ancestorAggregates), <a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a>(&amp;aggregate));</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    tweakedClause-&gt;apply(update);</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    <span class="comment">// the update will now tell us which variables we need to ground!</span></div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    <span class="keyword">auto</span> groundingAtom = mk&lt;Atom&gt;(<span class="stringliteral">&quot;+grounding_atom&quot;</span>);</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;    <span class="keywordflow">for</span> (std::string variableName : update.getAggregatorVariables()) {</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;        groundingAtom-&gt;addArgument(mk&lt;Variable&gt;(variableName));</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;    }</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    <span class="comment">// add the newly created grounding atom to the body</span></div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;    tweakedClause-&gt;addToBody(std::move(groundingAtom));</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160; </div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    std::set&lt;std::string&gt; injectedVariables;</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    <span class="comment">// Search through the tweakedClause to find groundings!</span></div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; argPair : <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a108a2d9570b44c655bf3165e8d8613d4">analysis::getGroundedTerms</a>(tu, *tweakedClause)) {</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;        <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* variable = <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span>Variable*<span class="keyword">&gt;</span>(argPair.first)) {</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;            <span class="keywordtype">bool</span> varIsGrounded = argPair.second;</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;            <span class="keywordflow">if</span> (varIsGrounded &amp;&amp; variablesInTargetAggregate.find(variable-&gt;getName()) !=</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;                                         variablesInTargetAggregate.end()) {</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;                <span class="comment">// then we have found an injected variable, lovely!!</span></div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;                injectedVariables.insert(variable-&gt;getName());</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;            }</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;        }</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;    }</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;    <span class="comment">// Remove any variables that occur in the target expression of the aggregate</span></div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;    <span class="keywordflow">if</span> (aggregate.getTargetExpression() != <span class="keyword">nullptr</span>) {</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;        <a class="code" href="namespacesouffle_1_1ast.html#a0bf6b9bdf0a8866bd27dde18442ab43d">visitDepthFirst</a>(*aggregate.getTargetExpression(),</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;                [&amp;](<span class="keyword">const</span> Variable&amp; v) { injectedVariables.erase(v.getName()); });</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;    }</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160; </div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;    <span class="keywordflow">return</span> injectedVariables;</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;}</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160; </div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;}  <span class="comment">// namespace souffle::ast::analysis</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac1acc981f913d4ad9865fb655fe5e1f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1acc981f913d4ad9865fb655fe5e1f2">&#9670;&nbsp;</a></span>getLocalVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; std::string &gt; souffle::ast::analysis::getLocalVariables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_translation_unit.html">TranslationUnit</a> &amp;&#160;</td>
          <td class="paramname"><em>tu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;&#160;</td>
          <td class="paramname"><em>clause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_aggregator.html">Aggregator</a> &amp;&#160;</td>
          <td class="paramname"><em>aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the set of local variables in an aggregate expression. </p>
<p>This is just the set of all variables occurring in the aggregate MINUS the injected variables MINUS the witness variables. :) </p>

<p class="definition">Definition at line <a class="el" href="_aggregate_8cpp_source.html#l00055">55</a> of file <a class="el" href="_aggregate_8cpp_source.html">Aggregate.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;                               : allVariablesInAggregate) {</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;        <span class="keywordflow">if</span> (injectedVariables.find(name) == injectedVariables.end() &amp;&amp;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;                witnessVariables.find(name) == witnessVariables.end()) {</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;            localVariables.insert(name);</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        }</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    }</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <span class="keywordflow">return</span> localVariables;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;}<span class="comment"></span></div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="comment"> * Computes the set of witness variables that are used in the aggregate</span></div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="comment"> * A variable is a witness if it occurs in the aggregate body (but not in an inner aggregate)</span></div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="comment"> * and also occurs ungrounded in the outer scope.</span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="comment"> **/</span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;std::set&lt;std::string&gt; <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#ac7dcac078836134ae4e1e59e4d3148e3">getWitnessVariables</a>(</div>
</div><!-- fragment -->
</div>
</div>
<a id="a82279ed776db311a2251771a38f80dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82279ed776db311a2251771a38f80dbe">&#9670;&nbsp;</a></span>getTypeAttribute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a> souffle::ast::analysis::getTypeAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00353">353</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;                                                                 {</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> typeAttribute : {TypeAttribute::Signed, TypeAttribute::Unsigned, TypeAttribute::Float,</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;                 TypeAttribute::Record, TypeAttribute::Symbol}) {</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a57035b21903488f1b7d1dbce08486cf5">isOfKind</a>(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>, typeAttribute)) {</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;            <span class="keywordflow">return</span> typeAttribute;</div>
</div><!-- fragment -->
</div>
</div>
<a id="aca099ea2c9cb2081b6295b0e58cc6e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca099ea2c9cb2081b6295b0e58cc6e58">&#9670;&nbsp;</a></span>getTypeAttribute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a> &gt; souffle::ast::analysis::getTypeAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_type_set.html">TypeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00363">363</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;           {};</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;}</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160; </div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;<span class="keywordtype">bool</span> <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a31d97aca50e40690287987996481844e">areEquivalentTypes</a>(<span class="keyword">const</span> Type&amp; a, <span class="keyword">const</span> Type&amp; <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>) {</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a7a59a824c8f1a160e57decfc92341203">isSubtypeOf</a>(a, <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>) &amp;&amp; <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a7a59a824c8f1a160e57decfc92341203">isSubtypeOf</a>(<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, a);</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;}</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160; </div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;<span class="keywordtype">bool</span> <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#ac71cbd339532f57b3611b7b493ce127e">isADTEnum</a>(<span class="keyword">const</span> AlgebraicDataType&amp; <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>) {</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7aa2c626b4878e0e5e1ae646ffdaa736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa2c626b4878e0e5e1ae646ffdaa736">&#9670;&nbsp;</a></span>getTypeQualifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::ast::analysis::getTypeQualifier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns full type qualifier for a given type. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00204">204</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;                                                       {</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;f&quot;</span>;</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a57035b21903488f1b7d1dbce08486cf5">isOfKind</a>(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>, TypeAttribute::Symbol)) {</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;s&quot;</span>;</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a57035b21903488f1b7d1dbce08486cf5">isOfKind</a>(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>, TypeAttribute::Record)) {</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;r&quot;</span>;</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a57035b21903488f1b7d1dbce08486cf5">isOfKind</a>(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>, TypeAttribute::ADT)) {</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;+&quot;</span>;</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;        } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;            <a class="code" href="namespacesouffle.html#a315141918c39611929a694840f046fb5">fatal</a>(<span class="stringliteral">&quot;Unsupported kind&quot;</span>);</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        }</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    }();</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160; </div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacetinyformat.html#adc3e74768f0e2204f9f9a726fc07ec61">tfm::format</a>(<span class="stringliteral">&quot;%s:%s&quot;</span>, kind, <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>.getName());</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;}</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160; </div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;<span class="keywordtype">bool</span> <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a7a59a824c8f1a160e57decfc92341203">isSubtypeOf</a>(<span class="keyword">const</span> Type&amp; a, <span class="keyword">const</span> Type&amp; <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>) {</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    assert(&amp;a.getTypeEnvironment() == &amp;<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>.getTypeEnvironment() &amp;&amp;</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;            <span class="stringliteral">&quot;Types must be in the same type environment&quot;</span>);</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160; </div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a3f0faa30c5f8af5d43f9b888018f7cc5">isOfRootType</a>(a, <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)) {</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_i_o_attributes_8h_source.html#l00245">souffle::ast::transform::IOAttributesTransformer::getRecordsTypes()</a>.</p>

</div>
</div>
<a id="a2e435338888fbb0a6cc096f1e699f637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e435338888fbb0a6cc096f1e699f637">&#9670;&nbsp;</a></span>getVariablesOutsideAggregate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; std::string &gt; souffle::ast::analysis::getVariablesOutsideAggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;&#160;</td>
          <td class="paramname"><em>clause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_aggregator.html">Aggregator</a> &amp;&#160;</td>
          <td class="paramname"><em>aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the set of variables occurring outside the aggregate. </p>
<p>Find the set of variable names occurring outside of the given aggregate.</p>
<p>This is equivalent to taking the set minus of the set of all variable names occurring in the clause minus the set of all variable names occurring in the aggregate. </p>

<p class="definition">Definition at line <a class="el" href="_aggregate_8cpp_source.html#l00164">164</a> of file <a class="el" href="_aggregate_8cpp_source.html">Aggregate.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;                                {</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;            variablesOutsideAggregate.insert(v);</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        }</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    }</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    <span class="keywordflow">return</span> variablesOutsideAggregate;</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;}</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160; </div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;std::string <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a9db4a30b81cfeab00fdbe334526fb30e">findUniqueVariableName</a>(<span class="keyword">const</span> Clause&amp; clause, std::string <a class="code" href="_reader_8h.html#a4ce824b383e7379148b61ee135baac5a">base</a>) {</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    std::set&lt;std::string&gt; variablesInClause;</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    <a class="code" href="namespacesouffle_1_1ast.html#a0bf6b9bdf0a8866bd27dde18442ab43d">visitDepthFirst</a>(clause, [&amp;](<span class="keyword">const</span> Variable&amp; v) { variablesInClause.insert(v.getName()); });</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;    <span class="keywordtype">int</span> varNum = 0;</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    std::string candidate = <a class="code" href="_reader_8h.html#a4ce824b383e7379148b61ee135baac5a">base</a>;</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_simplify_aggregate_target_expression_8cpp_source.html#l00029">souffle::ast::transform::SimplifyAggregateTargetExpressionTransformer::transform()</a>.</p>

</div>
</div>
<a id="ac7dcac078836134ae4e1e59e4d3148e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7dcac078836134ae4e1e59e4d3148e3">&#9670;&nbsp;</a></span>getWitnessVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; std::string &gt; souffle::ast::analysis::getWitnessVariables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_translation_unit.html">TranslationUnit</a> &amp;&#160;</td>
          <td class="paramname"><em>tu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;&#160;</td>
          <td class="paramname"><em>clause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_aggregator.html">Aggregator</a> &amp;&#160;</td>
          <td class="paramname"><em>aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the set of witness variables that are used in the aggregate A variable is a witness if it occurs in the aggregate body (but not in an inner aggregate) and also occurs ungrounded in the outer scope. </p>
<p>Computes the set of witness variables that are used in the aggregate. </p>

<p class="definition">Definition at line <a class="el" href="_aggregate_8cpp_source.html#l00075">75</a> of file <a class="el" href="_aggregate_8cpp_source.html">Aggregate.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;                                                          {</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;            <span class="keywordflow">return</span> aggregatorVariables;</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        }</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160; </div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        std::unique_ptr&lt;Node&gt; operator()(std::unique_ptr&lt;Node&gt; node)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;            <span class="keyword">static</span> <span class="keywordtype">int</span> numReplaced = 0;</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;            <span class="keywordflow">if</span> (<span class="keyword">dynamic_cast&lt;</span>Aggregator*<span class="keyword">&gt;</span>(node.get()) != <span class="keyword">nullptr</span>) {</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;                <span class="comment">// Replace the aggregator with a variable</span></div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;                std::stringstream newVariableName;</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;                newVariableName &lt;&lt; <span class="stringliteral">&quot;+aggr_var_&quot;</span> &lt;&lt; numReplaced++;</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160; </div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;                <span class="comment">// Keep track of which variables are bound to aggregators</span></div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;                aggregatorVariables.insert(newVariableName.str());</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160; </div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;                <span class="keywordflow">return</span> std::make_unique&lt;Variable&gt;(newVariableName.str());</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;            }</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;            node-&gt;apply(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;            <span class="keywordflow">return</span> node;</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;        }</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    };</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160; </div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <span class="keyword">auto</span> aggregatorlessClause = std::make_unique&lt;Clause&gt;();</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    aggregatorlessClause-&gt;setHead(std::make_unique&lt;Atom&gt;(<span class="stringliteral">&quot;*&quot;</span>));</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    <span class="keywordflow">for</span> (Literal* lit : clause.getBodyLiterals()) {</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        aggregatorlessClause-&gt;addToBody(<a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a>(lit));</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    }</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160; </div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    <span class="keyword">auto</span> negatedHead = std::make_unique&lt;Negation&gt;(<a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a>(clause.getHead()));</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    aggregatorlessClause-&gt;addToBody(std::move(negatedHead));</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160; </div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    <span class="comment">// Replace all aggregates with variables</span></div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    M update;</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    aggregatorlessClause-&gt;apply(update);</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    <span class="keyword">auto</span> groundingAtom = std::make_unique&lt;Atom&gt;(<span class="stringliteral">&quot;+grounding_atom&quot;</span>);</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    <span class="keywordflow">for</span> (std::string variableName : update.getAggregatorVariables()) {</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        groundingAtom-&gt;addArgument(std::make_unique&lt;Variable&gt;(variableName));</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    }</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    aggregatorlessClause-&gt;addToBody(std::move(groundingAtom));</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    <span class="comment">// 2. Create an aggregate clause so that we can check</span></div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    <span class="comment">// that it IS this aggregate giving a grounding to the candidate variable.</span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    <span class="keyword">auto</span> aggregateSubclause = std::make_unique&lt;Clause&gt;();</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    aggregateSubclause-&gt;setHead(mk&lt;Atom&gt;(<span class="stringliteral">&quot;*&quot;</span>));</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; lit : aggregate.getBodyLiterals()) {</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        aggregateSubclause-&gt;addToBody(<a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a>(lit));</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    }</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160; </div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    std::set&lt;std::string&gt; witnessVariables;</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    <span class="keyword">auto</span> isGroundedInAggregateSubclause = <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a108a2d9570b44c655bf3165e8d8613d4">analysis::getGroundedTerms</a>(tu, *aggregateSubclause);</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    <span class="comment">// 3. Calculate all the witness variables</span></div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    <span class="comment">// A witness will occur ungrounded in the aggregatorlessClause</span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; argPair : <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a108a2d9570b44c655bf3165e8d8613d4">analysis::getGroundedTerms</a>(tu, *aggregatorlessClause)) {</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* variable = <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span>Variable*<span class="keyword">&gt;</span>(argPair.first)) {</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;            <span class="keywordtype">bool</span> variableIsGrounded = argPair.second;</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;            <span class="keywordflow">if</span> (!variableIsGrounded) {</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;                <span class="comment">// then we expect it to be grounded in the aggregate subclause</span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;                <span class="comment">// if it&#39;s a witness!!</span></div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; aggArgPair : isGroundedInAggregateSubclause) {</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;                    <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* var = <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span>Variable*<span class="keyword">&gt;</span>(aggArgPair.first)) {</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;                        <span class="keywordtype">bool</span> aggVariableIsGrounded = aggArgPair.second;</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;                        <span class="keywordflow">if</span> (var-&gt;getName() == variable-&gt;getName() &amp;&amp; aggVariableIsGrounded) {</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;                            witnessVariables.insert(variable-&gt;getName());</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;                        }</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;                    }</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;                }</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;            }</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        }</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    }</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    <span class="comment">// 4. A witness variable may actually &quot;originate&quot; from an outer scope and</span></div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    <span class="comment">// just have been injected into this inner aggregate. Just check the set of injected variables</span></div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    <span class="comment">// and quickly minus them out.</span></div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    std::set&lt;std::string&gt; injectedVariables = <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#abbc7e3bf641dffe8a8dd0db3a8b44712">analysis::getInjectedVariables</a>(tu, clause, aggregate);</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> std::string&amp; injected : injectedVariables) {</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;        witnessVariables.erase(injected);</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    }</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160; </div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    <span class="keywordflow">return</span> witnessVariables;</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;}<span class="comment"></span></div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;<span class="comment"> *  Computes the set of variables occurring outside the aggregate</span></div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;<span class="comment"> **/</span></div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;std::set&lt;std::string&gt; <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a2e435338888fbb0a6cc096f1e699f637">getVariablesOutsideAggregate</a>(<span class="keyword">const</span> Clause&amp; clause, <span class="keyword">const</span> Aggregator&amp; aggregate) {</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    std::map&lt;std::string, int&gt; variableOccurrences;</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    <a class="code" href="namespacesouffle_1_1ast.html#a0bf6b9bdf0a8866bd27dde18442ab43d">visitDepthFirst</a>(clause, [&amp;](<span class="keyword">const</span> Variable&amp; var) { variableOccurrences[var.getName()]++; });</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_simplify_aggregate_target_expression_8cpp_source.html#l00029">souffle::ast::transform::SimplifyAggregateTargetExpressionTransformer::transform()</a>.</p>

</div>
</div>
<a id="a09ec4ec9ee27a1504619a34a39a59f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ec4ec9ee27a1504619a34a39a59f28">&#9670;&nbsp;</a></span>hasSuperTypeInSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a456aa88ad6dbd15a932359fa758ce4af">TypeConstraint</a> souffle::ast::analysis::hasSuperTypeInSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a1b1ecaed9c14b785760d185d1274a57b">TypeVar</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_type_set.html">TypeSet</a>&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A constraint factory ensuring that all the types associated to the variable are subtypes of some type in the provided set (values) </p>
<p>Values can't be all. </p>

<p class="definition">Definition at line <a class="el" href="_type_constraints_8cpp_source.html#l00077">77</a> of file <a class="el" href="_type_constraints_8cpp_source.html">TypeConstraints.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;                                       : var(std::move(var)), values(std::move(values)) {}</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160; </div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        <span class="keywordtype">bool</span> update(Assignment&lt;TypeVar&gt;&amp; assigment)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;            <span class="comment">// get current value of variable a</span></div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;            TypeSet&amp; assigments = assigment[var];</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160; </div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;            <span class="comment">// remove all types that are not sub-types of b</span></div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;            <span class="keywordflow">if</span> (assigments.isAll()) {</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;                assigments = values;</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;            }</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160; </div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;            TypeSet newAssigments;</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> Type&amp; <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a> : assigments) {</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;                <span class="keywordtype">bool</span> existsSuperTypeInValues =</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;                        <a class="code" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">any_of</a>(values, [&amp;<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>](<span class="keyword">const</span> Type&amp; value) { <span class="keywordflow">return</span> <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a0992f547add4896b9f5e220c3d945449">isSubtypeOf</a>(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>, value); });</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;                <span class="keywordflow">if</span> (existsSuperTypeInValues) {</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;                    newAssigments.insert(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>);</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;                }</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;            }</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;            <span class="comment">// check whether there was a change</span></div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;            <span class="keywordflow">if</span> (newAssigments == assigments) {</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;            }</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;            assigments = newAssigments;</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        }</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160; </div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        <span class="keywordtype">void</span> print(std::ostream&amp; out)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;            out &lt;&lt; <span class="stringliteral">&quot; t  &quot;</span> &lt;&lt; values &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; var &lt;&lt; <span class="stringliteral">&quot; &lt;: t&quot;</span>;</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        }</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    };</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160; </div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    <span class="keywordflow">return</span> std::make_shared&lt;C&gt;(var, values);</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;}</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160; </div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;<span class="keyword">static</span> <span class="keyword">const</span> Type&amp; <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a57b605f2d521905266c738460486e9eb">getBaseType</a>(<span class="keyword">const</span> Type* <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>) {</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    <span class="keywordflow">while</span> (<span class="keyword">auto</span> subset = <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span>SubsetType*<span class="keyword">&gt;</span>(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>)) {</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a> = &amp;subset-&gt;getBaseType();</div>
</div><!-- fragment -->
</div>
</div>
<a id="a884a05f7212028fe74129e203f6b370a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a884a05f7212028fe74129e203f6b370a">&#9670;&nbsp;</a></span>haveCommonSupertype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::ast::analysis::haveCommonSupertype </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if there exist a type t such that a &lt;: t and b &lt;: t. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00337">337</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;                                                {</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    }</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160; </div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">any_of</a>(a.getTypeEnvironment().getTypes(),</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;            [&amp;](<span class="keyword">const</span> Type&amp; <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>) { return isSubtypeOf(a, type) &amp;&amp; isSubtypeOf(b, type); });</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;}</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160; </div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;<a class="code" href="class_type_attribute.html">TypeAttribute</a> <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#aca099ea2c9cb2081b6295b0e58cc6e58">getTypeAttribute</a>(<span class="keyword">const</span> Type&amp; <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>) {</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> typeAttribute : {TypeAttribute::Signed, TypeAttribute::Unsigned, TypeAttribute::Float,</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;                 TypeAttribute::Record, TypeAttribute::Symbol}) {</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a57035b21903488f1b7d1dbce08486cf5">isOfKind</a>(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>, typeAttribute)) {</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;            <span class="keywordflow">return</span> typeAttribute;</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac71cbd339532f57b3611b7b493ce127e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71cbd339532f57b3611b7b493ce127e">&#9670;&nbsp;</a></span>isADTEnum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::ast::analysis::isADTEnum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_algebraic_data_type.html">AlgebraicDataType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if ADT is enumerations (are all constructors empty) </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00377">377</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

</div>
</div>
<a id="ab6d30670b31997c7653fb61b7c073f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d30670b31997c7653fb61b7c073f1b">&#9670;&nbsp;</a></span>isNumericType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::ast::analysis::isNumericType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_type_set.html">TypeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_system_8h_source.html#l00512">512</a> of file <a class="el" href="_type_system_8h_source.html">TypeSystem.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;                                                         {</div>
</div><!-- fragment -->
</div>
</div>
<a id="a03c482b5c5fefb75d263667dbe6b1995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c482b5c5fefb75d263667dbe6b1995">&#9670;&nbsp;</a></span>isOfKind() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::ast::analysis::isOfKind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a>&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the type is of a kind corresponding to the <a class="el" href="class_type_attribute.html" title="Type attribute class.">TypeAttribute</a>. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00189">189</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;                                                          {</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    <span class="keywordflow">return</span> !typeSet.empty() &amp;&amp; !typeSet.isAll() &amp;&amp;</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;           <a class="code" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">all_of</a>(typeSet, [&amp;](<span class="keyword">const</span> Type&amp; <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>) { <span class="keywordflow">return</span> <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a57035b21903488f1b7d1dbce08486cf5">isOfKind</a>(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>, kind); });</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;}</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160; </div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_type_system_8cpp_source.html#l00199">isOfKind()</a>, and <a class="el" href="_type_checker_8cpp_source.html#l00362">souffle::ast::transform::TypeCheckerImpl::visitVariable()</a>.</p>

</div>
</div>
<a id="a57035b21903488f1b7d1dbce08486cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57035b21903488f1b7d1dbce08486cf5">&#9670;&nbsp;</a></span>isOfKind() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::ast::analysis::isOfKind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_type_set.html">TypeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>typeSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a>&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00199">199</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;                           {</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a57035b21903488f1b7d1dbce08486cf5">isOfKind</a>(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>, TypeAttribute::Signed)) {</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;i&quot;</span>;</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a57035b21903488f1b7d1dbce08486cf5">isOfKind</a>(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>, TypeAttribute::Unsigned)) {</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_type_system_8cpp_source.html#l00189">isOfKind()</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a71fed0c3428bf1a2e19af257c4bac379">souffle::Signed</a>, and <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0aa1a914735b205424ba6c40b85528d78a">souffle::Unsigned</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_1_1ast_1_1analysis_a57035b21903488f1b7d1dbce08486cf5_cgraph.png" border="0" usemap="#namespacesouffle_1_1ast_1_1analysis_a57035b21903488f1b7d1dbce08486cf5_cgraph" alt=""/></div>
<map name="namespacesouffle_1_1ast_1_1analysis_a57035b21903488f1b7d1dbce08486cf5_cgraph" id="namespacesouffle_1_1ast_1_1analysis_a57035b21903488f1b7d1dbce08486cf5_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,161,47"/>
<area shape="rect" href="namespacesouffle_1_1ast_1_1analysis.html#a03c482b5c5fefb75d263667dbe6b1995" title="Check if the type is of a kind corresponding to the TypeAttribute." alt="" coords="209,5,365,47"/>
</map>
</div>

</div>
</div>
<a id="a3f0faa30c5f8af5d43f9b888018f7cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0faa30c5f8af5d43f9b888018f7cc5">&#9670;&nbsp;</a></span>isOfRootType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::ast::analysis::isOfRootType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the given type is a sub-type of the given root type. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00155">155</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;                                                                        {</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a> == root;</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        }</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;        <span class="keywordtype">bool</span> visitSubsetType(<span class="keyword">const</span> SubsetType&amp; <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a> == root || <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a3f0faa30c5f8af5d43f9b888018f7cc5">isOfRootType</a>(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>.getBaseType(), root);</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;        }</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160; </div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;        <span class="keywordtype">bool</span> visitAlgebraicDataType(<span class="keyword">const</span> AlgebraicDataType&amp; <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a> == root;</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        }</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160; </div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        <span class="keywordtype">bool</span> visitUnionType(<span class="keyword">const</span> UnionType&amp; <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a> == root ||</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;                   <a class="code" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">all_of</a>(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>.getElementTypes(), [&amp;](<span class="keyword">const</span> Type* cur) { return this-&gt;visit(*cur); });</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        }</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160; </div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        <span class="keywordtype">bool</span> visitRecordType(<span class="keyword">const</span> RecordType&amp; <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a> == root;</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;        }</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160; </div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;        <span class="keywordtype">bool</span> visitType(<span class="keyword">const</span> Type&amp; <span class="comment">/*unused*/</span>)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;        }</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    };</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160; </div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    <span class="keywordflow">return</span> visitor(root).visit(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>);</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;}</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160; </div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;<span class="keywordtype">bool</span> <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a57035b21903488f1b7d1dbce08486cf5">isOfKind</a>(<span class="keyword">const</span> Type&amp; <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>, <a class="code" href="class_type_attribute.html">TypeAttribute</a> kind) {</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;    <span class="keywordflow">if</span> (kind == TypeAttribute::Record) {</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        <span class="keywordflow">return</span> isA&lt;RecordType&gt;(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>);</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (kind == TypeAttribute::ADT) {</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;        <span class="keywordflow">return</span> isA&lt;AlgebraicDataType&gt;(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>);</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac16af0a5743a33b616da4f47bdd5bc56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16af0a5743a33b616da4f47bdd5bc56">&#9670;&nbsp;</a></span>isOrderableType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::ast::analysis::isOrderableType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsouffle_1_1ast_1_1analysis_1_1_type_set.html">TypeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_system_8h_source.html#l00517">517</a> of file <a class="el" href="_type_system_8h_source.html">TypeSystem.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;                                                         {</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7a59a824c8f1a160e57decfc92341203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a59a824c8f1a160e57decfc92341203">&#9670;&nbsp;</a></span>isSubtypeOf() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::ast::analysis::isSubtypeOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether type a is a subtype of type b. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00226">226</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;                           {</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">all_of</a>(<span class="keyword">static_cast&lt;</span><span class="keyword">const </span>UnionType&amp;<span class="keyword">&gt;</span>(a).getElementTypes(),</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;                [&amp;<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>](<span class="keyword">const</span> Type* <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>) { <span class="keywordflow">return</span> <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a7a59a824c8f1a160e57decfc92341203">isSubtypeOf</a>(*<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>, <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>); });</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    }</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160; </div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    <span class="keywordflow">if</span> (isA&lt;UnionType&gt;(<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)) {</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">any_of</a>(<span class="keyword">static_cast&lt;</span><span class="keyword">const </span>UnionType&amp;<span class="keyword">&gt;</span>(<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>).getElementTypes(),</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;                [&amp;a](<span class="keyword">const</span> Type* <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>) { <span class="keywordflow">return</span> <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a7a59a824c8f1a160e57decfc92341203">isSubtypeOf</a>(a, *<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>); });</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;    }</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160; </div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;}</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160; </div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;<span class="keywordtype">void</span> TypeEnvironment::print(std::ostream&amp; out)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    out &lt;&lt; <span class="stringliteral">&quot;Types:\n&quot;</span>;</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; cur : <a class="code" href="_component_instantiation_8cpp.html#aaa259cf5782448e1215a879c8f02d6d5">types</a>) {</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;        out &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; *cur.second &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0bf3d7f4bb24ba4705fc57759c922ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf3d7f4bb24ba4705fc57759c922ab6">&#9670;&nbsp;</a></span>isSubtypeOf() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a456aa88ad6dbd15a932359fa758ce4af">TypeConstraint</a> souffle::ast::analysis::isSubtypeOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a1b1ecaed9c14b785760d185d1274a57b">TypeVar</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a1b1ecaed9c14b785760d185d1274a57b">TypeVar</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A constraint factory ensuring that all the types associated to the variable a are subtypes of the variable b. </p>

<p class="definition">Definition at line <a class="el" href="_type_constraints_8cpp_source.html#l00027">27</a> of file <a class="el" href="_type_constraints_8cpp_source.html">TypeConstraints.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;                                                                             {</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_type_system_8cpp_source.html#l00247">souffle::ast::analysis::TypeEnvironment::print()</a>, and <a class="el" href="_type_constraints_8cpp_source.html#l00415">souffle::ast::analysis::TypeConstraintsAnalysis::visitNegation()</a>.</p>

</div>
</div>
<a id="a0992f547add4896b9f5e220c3d945449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0992f547add4896b9f5e220c3d945449">&#9670;&nbsp;</a></span>isSubtypeOf() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a456aa88ad6dbd15a932359fa758ce4af">TypeConstraint</a> souffle::ast::analysis::isSubtypeOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a1b1ecaed9c14b785760d185d1274a57b">TypeVar</a> &amp;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A constraint factory ensuring that all the types associated to the variable a are subtypes of type b. </p>

<p class="definition">Definition at line <a class="el" href="_type_constraints_8cpp_source.html#l00035">35</a> of file <a class="el" href="_type_constraints_8cpp_source.html">TypeConstraints.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;                                              : variable(std::move(variable)), <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>) {}</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160; </div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        <span class="keywordtype">bool</span> update(Assignment&lt;TypeVar&gt;&amp; assignments)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;            TypeSet&amp; assignment = assignments[variable];</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160; </div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;            <span class="keywordflow">if</span> (assignment.isAll()) {</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;                assignment = TypeSet(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>);</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;            }</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160; </div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;            TypeSet newAssignment;</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> Type&amp; t : assignment) {</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;                newAssignment.insert(<a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a1073ec3616e2b1e5628ef038ce21e975">getGreatestCommonSubtypes</a>(t, <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>));</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;            }</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160; </div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;            <span class="comment">// check whether there was a change</span></div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;            <span class="keywordflow">if</span> (assignment == newAssignment) {</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;            }</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;            assignment = newAssignment;</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;        }</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160; </div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;        <span class="keywordtype">void</span> print(std::ostream&amp; out)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;            out &lt;&lt; variable &lt;&lt; <span class="stringliteral">&quot; &lt;: &quot;</span> &lt;&lt; <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>.getName();</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        }</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    };</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160; </div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    <span class="keywordflow">return</span> std::make_shared&lt;C&gt;(variable, <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>);</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;}</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="comment"> * A constraint factory ensuring that all the types associated to the variable</span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;<span class="comment"> * are subtypes of some type in the provided set (values)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a749706946fac0387109eba3029f778bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a749706946fac0387109eba3029f778bd">&#9670;&nbsp;</a></span>isSubtypeOfComponent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a456aa88ad6dbd15a932359fa758ce4af">TypeConstraint</a> souffle::ast::analysis::isSubtypeOfComponent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a1b1ecaed9c14b785760d185d1274a57b">TypeVar</a> &amp;&#160;</td>
          <td class="paramname"><em>elementVariable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a1b1ecaed9c14b785760d185d1274a57b">TypeVar</a> &amp;&#160;</td>
          <td class="paramname"><em>recordVariable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_constraint.html" title="A generic base class for constraints on variables.">Constraint</a> on record type and its elements. </p>

<p class="definition">Definition at line <a class="el" href="_type_constraints_8cpp_source.html#l00320">320</a> of file <a class="el" href="_type_constraints_8cpp_source.html">TypeConstraints.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;                : elementVariable(std::move(elementVariable)), recordVariable(std::move(recordVariable)),</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;                  index(index) {}</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160; </div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;        <span class="keywordtype">bool</span> update(Assignment&lt;TypeVar&gt;&amp; assignment)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;            <span class="comment">// get list of types for b</span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;            <span class="keyword">const</span> TypeSet&amp; recordTypes = assignment[recordVariable];</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160; </div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;            <span class="comment">// if it is (not yet) constrainted =&gt; skip</span></div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;            <span class="keywordflow">if</span> (recordTypes.isAll()) {</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;            }</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160; </div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;            <span class="comment">// compute new types for element and record</span></div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;            TypeSet newElementTypes;</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;            TypeSet newRecordTypes;</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160; </div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> Type&amp; <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a> : recordTypes) {</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;                <span class="comment">// A type must be either a record type or a subset of a record type</span></div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;                <span class="keywordflow">if</span> (!<a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a03c482b5c5fefb75d263667dbe6b1995">isOfKind</a>(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>, TypeAttribute::Record)) {</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;                    <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;                }</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160; </div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;                <span class="keyword">const</span> <span class="keyword">auto</span>&amp; typeAsRecord = *as&lt;RecordType&gt;(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>);</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160; </div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;                <span class="comment">// Wrong size =&gt; skip.</span></div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;                <span class="keywordflow">if</span> (typeAsRecord.getFields().size() &lt;= index) {</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;                    <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;                }</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160; </div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;                <span class="comment">// Valid type for record.</span></div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;                newRecordTypes.insert(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>);</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160; </div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;                <span class="comment">// and its corresponding field.</span></div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;                newElementTypes.insert(*typeAsRecord.getFields()[index]);</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;            }</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160; </div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;            <span class="comment">// combine with current types assigned to element</span></div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;            newElementTypes = <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a1073ec3616e2b1e5628ef038ce21e975">getGreatestCommonSubtypes</a>(assignment[elementVariable], newElementTypes);</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160; </div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;            <span class="comment">// update values</span></div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;            <span class="keywordtype">bool</span> changed = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;            <span class="keywordflow">if</span> (newRecordTypes != recordTypes) {</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;                assignment[recordVariable] = newRecordTypes;</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;                changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;            }</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160; </div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;            <span class="keywordflow">if</span> (assignment[elementVariable] != newElementTypes) {</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;                assignment[elementVariable] = newElementTypes;</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;                changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;            }</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160; </div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;            <span class="keywordflow">return</span> changed;</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;        }</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160; </div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;        <span class="keywordtype">void</span> print(std::ostream&amp; out)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;            out &lt;&lt; elementVariable &lt;&lt; <span class="stringliteral">&quot; &lt;: &quot;</span> &lt;&lt; recordVariable &lt;&lt; <span class="stringliteral">&quot;::&quot;</span> &lt;&lt; index;</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        }</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;    };</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160; </div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;    <span class="keywordflow">return</span> std::make_shared&lt;C&gt;(elementVariable, recordVariable, index);</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;}</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160; </div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;<span class="keywordtype">void</span> TypeConstraintsAnalysis::visitSink(<span class="keyword">const</span> Atom&amp; atom) {</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;    iterateOverAtom(atom, [&amp;](<span class="keyword">const</span> Argument&amp; argument, <span class="keyword">const</span> Type&amp; attributeType) {</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;        <span class="keywordflow">if</span> (isA&lt;RecordType&gt;(attributeType)) {</div>
</div><!-- fragment -->
</div>
</div>
<a id="acd84a9ac1ca23adad8d76e0b1ac4cc3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd84a9ac1ca23adad8d76e0b1ac4cc3d">&#9670;&nbsp;</a></span>satisfiesOverload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a456aa88ad6dbd15a932359fa758ce4af">TypeConstraint</a> souffle::ast::analysis::satisfiesOverload </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_type_environment.html">TypeEnvironment</a> &amp;&#160;</td>
          <td class="paramname"><em>typeEnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesouffle.html#ab7b7797c4980b8080efdcecc75e684bc">IntrinsicFunctors</a>&#160;</td>
          <td class="paramname"><em>overloads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a1b1ecaed9c14b785760d185d1274a57b">TypeVar</a>&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a1b1ecaed9c14b785760d185d1274a57b">TypeVar</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>subtypeResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a set of overloads, wait the list of candidates to reduce to one and then apply its constraints. </p>
<p>NOTE: <code>subtypeResult</code> implies that <code>func &lt;: overload-return-type</code>, rather than <code>func = overload-return-type</code>. This is required for old type semantics. See #1296 and tests/semantic/type_system4 </p>

<p class="definition">Definition at line <a class="el" href="_type_constraints_8cpp_source.html#l00230">230</a> of file <a class="el" href="_type_constraints_8cpp_source.html">TypeConstraints.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;                : typeEnv(typeEnv), overloads(std::move(overloads)), result(std::move(result)),</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;                  args(std::move(args)), subtypeResult(subtypeResult) {}</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160; </div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;        <span class="keywordtype">bool</span> update(Assignment&lt;TypeVar&gt;&amp; assigment)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;            <span class="keyword">auto</span> subtypesOf = [&amp;](<span class="keyword">const</span> TypeSet&amp; src, <a class="code" href="class_type_attribute.html">TypeAttribute</a> tyAttr) {</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;                <span class="keyword">auto</span>&amp; ty = typeEnv.getConstantType(tyAttr);</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;                <span class="keywordflow">return</span> src.filter(TypeSet(<span class="keyword">true</span>), [&amp;](<span class="keyword">auto</span>&amp;&amp; x) { <span class="keywordflow">return</span> <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a0992f547add4896b9f5e220c3d945449">isSubtypeOf</a>(x, ty); });</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;            };</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160; </div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;            <span class="keyword">auto</span> possible = [&amp;](<a class="code" href="class_type_attribute.html">TypeAttribute</a> ty, <span class="keyword">const</span> <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a1b1ecaed9c14b785760d185d1274a57b">TypeVar</a>&amp; var) {</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;                <span class="keyword">auto</span>&amp; curr = assigment[var];</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;                <span class="keywordflow">return</span> curr.isAll() || <a class="code" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">any_of</a>(curr, [&amp;](<span class="keyword">auto</span>&amp;&amp; t) { <span class="keywordflow">return</span> <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a82279ed776db311a2251771a38f80dbe">getTypeAttribute</a>(t) == ty; });</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;            };</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160; </div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;            overloads = <a class="code" href="namespacesouffle.html#a6502e279c40a34078cb9d93a465c7590">filterNot</a>(std::move(overloads), [&amp;](<span class="keyword">const</span> IntrinsicFunctorInfo&amp; x) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;                <span class="keywordflow">if</span> (!x.variadic &amp;&amp; args.size() != x.params.size()) <span class="keywordflow">return</span> <span class="keyword">true</span>;  <span class="comment">// arity mismatch?</span></div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160; </div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;                for (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; args.size(); ++<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>) {</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;                    <span class="keywordflow">if</span> (!possible(x.params[x.variadic ? 0 : <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>], args[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>])) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;                }</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160; </div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;                <span class="keywordflow">return</span> !possible(x.result, result);</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;            });</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160; </div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;            <span class="keywordtype">bool</span> changed = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;            <span class="keyword">auto</span> newResult = [&amp;]() -&gt; std::optional&lt;TypeSet&gt; {</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;                <span class="keywordflow">if</span> (0 == overloads.size()) <span class="keywordflow">return</span> TypeSet();</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;                <span class="keywordflow">if</span> (1 &lt; overloads.size()) <span class="keywordflow">return</span> {};</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160; </div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;                <span class="keyword">auto</span>&amp; overload = overloads.front().get();</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;                <span class="comment">// `ord` is freakin&#39; magical: it has the signature `a -&gt; Int`.</span></div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;                <span class="comment">// As a consequence, we might be given non-primitive arguments (i.e. types for which</span></div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;                <span class="comment">// `TypeEnv::getConstantType` is undefined).</span></div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;                <span class="comment">// Handle this by not imposing constraints on the arguments.</span></div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;                <span class="keywordflow">if</span> (overload.op != FunctorOp::ORD) {</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;                    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; args.size(); ++<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>) {</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;                        <span class="keyword">auto</span> argTy = overload.params[overload.variadic ? 0 : <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;                        <span class="keyword">auto</span>&amp; currArg = assigment[args[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>]];</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;                        <span class="keyword">auto</span> newArg = subtypesOf(currArg, argTy);</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;                        changed |= currArg != newArg;</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;                        <span class="comment">// 2020-05-09: CI linter says to remove `std::move`, but clang-tidy-10 is happy.</span></div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;                        currArg = std::move(newArg);  <span class="comment">// NOLINT</span></div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;                    }</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;                }</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160; </div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;                <span class="keywordflow">if</span> (nonMonotonicUpdate || subtypeResult) {</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;                    <span class="keywordflow">return</span> subtypesOf(assigment[result], overload.result);</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;                    nonMonotonicUpdate = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;                    <span class="keywordflow">return</span> TypeSet{typeEnv.getConstantType(overload.result)};</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;                }</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;            }();</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160; </div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;            <span class="keywordflow">if</span> (newResult) {</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;                <span class="keyword">auto</span>&amp; curr = assigment[result];</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;                changed |= curr != *newResult;</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;                <span class="comment">// 2020-05-09: CI linter says to remove `std::move`, but clang-tidy-10 is happy.</span></div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;                curr = std::move(*newResult);  <span class="comment">// NOLINT</span></div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;            }</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160; </div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;            <span class="keywordflow">return</span> changed;</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;        }</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160; </div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;        <span class="keywordtype">void</span> print(std::ostream&amp; out)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;            <span class="comment">// TODO (darth_tytus): is this description correct?</span></div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;            out &lt;&lt; <span class="stringliteral">&quot; t : &quot;</span> &lt;&lt; result &lt;&lt; <span class="stringliteral">&quot; &lt;: t where t is a base type&quot;</span>;</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;        }</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;    };</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160; </div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;    <span class="keywordflow">return</span> std::make_shared&lt;C&gt;(</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;            typeEnv, std::move(overloads), std::move(result), std::move(args), subtypeResult);</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;}</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;<span class="comment"> * Constraint on record type and its elements.</span></div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;<span class="comment"> */</span></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_type_constraints_8cpp_source.html#l00490">souffle::ast::analysis::TypeConstraintsAnalysis::visitFunctor()</a>.</p>

</div>
</div>
<a id="a7fc00ad3ca3158b1b85df24c67b10961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc00ad3ca3158b1b85df24c67b10961">&#9670;&nbsp;</a></span>sub() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Var , typename Val  = typename Var::property_space::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_constraint.html">Constraint</a>&lt;Var&gt; &gt; souffle::ast::analysis::sub </td>
          <td>(</td>
          <td class="paramtype">const Val &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Var &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic factory for constraints of the form. </p>
<pre class="fragment">                           a  b
</pre><p>where b is a variables, a is a value of b's property space, and  is the order relation induced by b's property space. </p>

<p class="definition">Definition at line <a class="el" href="_constraint_system_8h_source.html#l00257">257</a> of file <a class="el" href="_constraint_system_8h_source.html">ConstraintSystem.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;                                            : a(std::move(a)), <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>(std::move(<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)), symbol(std::move(symbol)) {}</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160; </div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;        <span class="keywordtype">bool</span> update(Assignment&lt;Var&gt;&amp; ass)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;            <span class="keyword">typename</span> Var::property_space::meet_assign_op_type meet_assign;</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;            <span class="keywordflow">return</span> meet_assign(ass[<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>], a);</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;        }</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160; </div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;        <span class="keywordtype">void</span> print(std::ostream&amp; out)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;            out &lt;&lt; a &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; symbol &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>;</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;        }</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;    };</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160; </div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;    <span class="keywordflow">return</span> std::make_shared&lt;Sub&gt;(a, <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, symbol);</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;}</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160; </div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;<span class="comment">//----------------------------------------------------------------------</span></div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;<span class="comment">//                           assignment</span></div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;<span class="comment">//----------------------------------------------------------------------</span></div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;<span class="comment">/**</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="af454c8b25ece926ca5206774d8f23be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af454c8b25ece926ca5206774d8f23be1">&#9670;&nbsp;</a></span>sub() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Var &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_constraint.html">Constraint</a>&lt;Var&gt; &gt; souffle::ast::analysis::sub </td>
          <td>(</td>
          <td class="paramtype">const Var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Var &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic factory for constraints of the form. </p>
<pre class="fragment">                           a  b
</pre><p>where a and b are variables and  is the order relation induced by their associated property space. </p>

<p class="definition">Definition at line <a class="el" href="_constraint_system_8h_source.html#l00228">228</a> of file <a class="el" href="_constraint_system_8h_source.html">ConstraintSystem.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;                                                         {</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;            <span class="keyword">typename</span> Var::property_space::meet_assign_op_type meet_assign;</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;            <span class="keywordflow">return</span> meet_assign(ass[<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>], ass[a]);</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;        }</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160; </div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;        <span class="keywordtype">void</span> print(std::ostream&amp; out)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;            out &lt;&lt; a &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; symbol &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>;</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;        }</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;    };</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160; </div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    <span class="keywordflow">return</span> std::make_shared&lt;Sub&gt;(a, <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, symbol);</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;}</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;<span class="comment"> * A generic factory for constraints of the form</span></div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;<span class="comment"> *                                a  b</span></div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;<span class="comment"> *</span></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="html_js_chartist_min_8h_source.html#l00015">b</a>.</p>

<p class="reference">Referenced by <a class="el" href="ram_2_program_8h_source.html#l00110">souffle::ram::Program::clone()</a>, <a class="el" href="ram_2_program_8h_source.html#l00074">souffle::ram::Program::getChildNodes()</a>, <a class="el" href="ram_2_program_8h_source.html#l00092">souffle::ram::Program::getRelations()</a>, <a class="el" href="ram_2_program_8h_source.html#l00133">souffle::ram::Program::print()</a>, <a class="el" href="ram_2_program_8h_source.html#l00063">souffle::ram::Program::Program()</a>, and <a class="el" href="_inline_relations_8cpp_source.html#l00219">souffle::ast::transform::reduceSubstitution()</a>.</p>

</div>
</div>
<a id="a9eb6a5b6fc9b260aee7e0989cd638fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb6a5b6fc9b260aee7e0989cd638fa8">&#9670;&nbsp;</a></span>subtypesOfTheSameBaseType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a456aa88ad6dbd15a932359fa758ce4af">TypeConstraint</a> souffle::ast::analysis::subtypesOfTheSameBaseType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a1b1ecaed9c14b785760d185d1274a57b">TypeVar</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesouffle_1_1ast_1_1analysis.html#a1b1ecaed9c14b785760d185d1274a57b">TypeVar</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensure that types of left and right have the same base types. </p>

<p class="definition">Definition at line <a class="el" href="_type_constraints_8cpp_source.html#l00130">130</a> of file <a class="el" href="_type_constraints_8cpp_source.html">TypeConstraints.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;                                       : left(std::move(left)), right(std::move(right)) {}</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160; </div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;        <span class="keywordtype">bool</span> update(Assignment&lt;TypeVar&gt;&amp; assigment)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;            <span class="comment">// get current value of variable a</span></div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;            TypeSet&amp; assigmentsLeft = assigment[left];</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;            TypeSet&amp; assigmentsRight = assigment[right];</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160; </div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;            <span class="comment">// Base types common to left and right variables.</span></div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;            TypeSet baseTypes;</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160; </div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;            <span class="comment">// Base types present in left/right variable.</span></div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;            TypeSet baseTypesLeft;</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;            TypeSet baseTypesRight;</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160; </div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;            <span class="comment">// Iterate over possible types extracting base types.</span></div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;            <span class="comment">// Left</span></div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;            <span class="keywordflow">if</span> (!assigmentsLeft.isAll()) {</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">const</span> Type&amp; <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a> : assigmentsLeft) {</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;                    <span class="keywordflow">if</span> (isA&lt;SubsetType&gt;(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>) || isA&lt;ConstantType&gt;(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>)) {</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;                        baseTypesLeft.insert(<a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a57b605f2d521905266c738460486e9eb">getBaseType</a>(&amp;<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>));</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;                    }</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;                }</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;            }</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;            <span class="comment">// Right</span></div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;            <span class="keywordflow">if</span> (!assigmentsRight.isAll()) {</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">const</span> Type&amp; <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a> : assigmentsRight) {</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;                    <span class="keywordflow">if</span> (isA&lt;SubsetType&gt;(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>) || isA&lt;ConstantType&gt;(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>)) {</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;                        baseTypesRight.insert(<a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a57b605f2d521905266c738460486e9eb">getBaseType</a>(&amp;<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>));</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;                    }</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;                }</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;            }</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160; </div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;            TypeSet resultLeft;</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;            TypeSet resultRight;</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160; </div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;            <span class="comment">// Handle all</span></div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;            <span class="keywordflow">if</span> (assigmentsLeft.isAll() &amp;&amp; assigmentsRight.isAll()) {</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;            }</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160; </div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;            <span class="comment">// If left xor right is all, assign base types of the other side as possible values.</span></div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;            <span class="keywordflow">if</span> (assigmentsLeft.isAll()) {</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;                assigmentsLeft = baseTypesRight;</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;            }</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;            <span class="keywordflow">if</span> (assigmentsRight.isAll()) {</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;                assigmentsRight = baseTypesLeft;</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;            }</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160; </div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;            baseTypes = TypeSet::intersection(baseTypesLeft, baseTypesRight);</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160; </div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;            <span class="comment">// Allow types if they are subtypes of any of the common base types.</span></div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> Type&amp; <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a> : assigmentsLeft) {</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;                <span class="keywordtype">bool</span> isSubtypeOfCommonBaseType = <a class="code" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">any_of</a>(baseTypes.begin(), baseTypes.end(),</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;                        [&amp;<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>](<span class="keyword">const</span> Type&amp; baseType) { return isSubtypeOf(type, baseType); });</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;                <span class="keywordflow">if</span> (isSubtypeOfCommonBaseType) {</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;                    resultLeft.insert(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>);</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;                }</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;            }</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160; </div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> Type&amp; <a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a> : assigmentsRight) {</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;                <span class="keywordtype">bool</span> isSubtypeOfCommonBaseType = <a class="code" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">any_of</a>(baseTypes.begin(), baseTypes.end(),</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;                        [&amp;<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>](<span class="keyword">const</span> Type&amp; baseType) { return isSubtypeOf(type, baseType); });</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;                <span class="keywordflow">if</span> (isSubtypeOfCommonBaseType) {</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;                    resultRight.insert(<a class="code" href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">type</a>);</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;                }</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;            }</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160; </div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;            <span class="comment">// check whether there was a change</span></div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;            <span class="keywordflow">if</span> (resultLeft == assigmentsLeft &amp;&amp; resultRight == assigmentsRight) {</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;            }</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;            assigmentsLeft = resultLeft;</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;            assigmentsRight = resultRight;</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;        }</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;        <span class="comment">//</span></div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;        <span class="keywordtype">void</span> print(std::ostream&amp; out)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;            out &lt;&lt; <span class="stringliteral">&quot; t : (&quot;</span> &lt;&lt; left &lt;&lt; <span class="stringliteral">&quot; &lt;: t)&quot;</span></div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;                &lt;&lt; <span class="stringliteral">&quot;  &quot;</span></div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;                &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; right &lt;&lt; <span class="stringliteral">&quot; &lt;: t)&quot;</span></div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;                &lt;&lt; <span class="stringliteral">&quot; where t is a base type&quot;</span>;</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        }</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    };</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160; </div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    <span class="keywordflow">return</span> std::make_shared&lt;C&gt;(left, right);</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;}</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;<span class="comment"> * Given a set of overloads, wait the list of candidates to reduce to one and then apply its constraints.</span></div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;<span class="comment"> * NOTE:  `subtypeResult` implies that `func &lt;: overload-return-type`, rather than</span></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_type_constraints_8cpp_source.html#l00490">souffle::ast::analysis::TypeConstraintsAnalysis::visitFunctor()</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespacesouffle_1_1ast_1_1analysis_html_a57035b21903488f1b7d1dbce08486cf5"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#a57035b21903488f1b7d1dbce08486cf5">souffle::ast::analysis::isOfKind</a></div><div class="ttdeci">bool isOfKind(const TypeSet &amp;typeSet, TypeAttribute kind)</div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00199">TypeSystem.cpp:199</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1analysis_html_a03c482b5c5fefb75d263667dbe6b1995"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#a03c482b5c5fefb75d263667dbe6b1995">souffle::ast::analysis::isOfKind</a></div><div class="ttdeci">bool isOfKind(const Type &amp;type, TypeAttribute kind)</div><div class="ttdoc">Check if the type is of a kind corresponding to the TypeAttribute.</div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00189">TypeSystem.cpp:189</a></div></div>
<div class="ttc" id="aclass_type_attribute_html"><div class="ttname"><a href="class_type_attribute.html">TypeAttribute</a></div><div class="ttdoc">Type attribute class.</div></div>
<div class="ttc" id="anamespacesouffle_html_a6502e279c40a34078cb9d93a465c7590"><div class="ttname"><a href="namespacesouffle.html#a6502e279c40a34078cb9d93a465c7590">souffle::filterNot</a></div><div class="ttdeci">std::vector&lt; A &gt; filterNot(std::vector&lt; A &gt; xs, F &amp;&amp;f)</div><div class="ttdoc">Filter a vector to exclude certain elements.</div><div class="ttdef"><b>Definition:</b> <a href="_functional_util_8h_source.html#l00146">FunctionalUtil.h:146</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1analysis_html_a31d97aca50e40690287987996481844e"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#a31d97aca50e40690287987996481844e">souffle::ast::analysis::areEquivalentTypes</a></div><div class="ttdeci">bool areEquivalentTypes(const Type &amp;a, const Type &amp;b)</div><div class="ttdoc">Determine if two types are equivalent.</div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00373">TypeSystem.cpp:373</a></div></div>
<div class="ttc" id="anamespacetinyformat_html_adc3e74768f0e2204f9f9a726fc07ec61"><div class="ttname"><a href="namespacetinyformat.html#adc3e74768f0e2204f9f9a726fc07ec61">tinyformat::format</a></div><div class="ttdeci">void format(std::ostream &amp;out, const char *fmt)</div><div class="ttdef"><b>Definition:</b> <a href="tinyformat_8h_source.html#l01089">tinyformat.h:1089</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1analysis_html_ac71cbd339532f57b3611b7b493ce127e"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#ac71cbd339532f57b3611b7b493ce127e">souffle::ast::analysis::isADTEnum</a></div><div class="ttdeci">bool isADTEnum(const AlgebraicDataType &amp;type)</div><div class="ttdoc">Determine if ADT is enumerations (are all constructors empty)</div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00377">TypeSystem.cpp:377</a></div></div>
<div class="ttc" id="a_component_instantiation_8cpp_html_aaa259cf5782448e1215a879c8f02d6d5"><div class="ttname"><a href="_component_instantiation_8cpp.html#aaa259cf5782448e1215a879c8f02d6d5">types</a></div><div class="ttdeci">std::vector&lt; Own&lt; ast::Type &gt; &gt; types</div><div class="ttdef"><b>Definition:</b> <a href="_component_instantiation_8cpp_source.html#l00064">ComponentInstantiation.cpp:64</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1analysis_html_a57b605f2d521905266c738460486e9eb"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#a57b605f2d521905266c738460486e9eb">souffle::ast::analysis::getBaseType</a></div><div class="ttdeci">static const Type &amp; getBaseType(const Type *type)</div><div class="ttdef"><b>Definition:</b> <a href="_type_constraints_8cpp_source.html#l00118">TypeConstraints.cpp:118</a></div></div>
<div class="ttc" id="a_reader_8h_html_a4ce824b383e7379148b61ee135baac5a"><div class="ttname"><a href="_reader_8h.html#a4ce824b383e7379148b61ee135baac5a">base</a></div><div class="ttdeci">T &amp; base</div><div class="ttdef"><b>Definition:</b> <a href="_reader_8h_source.html#l00060">Reader.h:60</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1analysis_html_a884a05f7212028fe74129e203f6b370a"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#a884a05f7212028fe74129e203f6b370a">souffle::ast::analysis::haveCommonSupertype</a></div><div class="ttdeci">bool haveCommonSupertype(const Type &amp;a, const Type &amp;b)</div><div class="ttdoc">Determine if there exist a type t such that a &lt;: t and b &lt;: t.</div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00337">TypeSystem.cpp:337</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1analysis_html_a108a2d9570b44c655bf3165e8d8613d4"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#a108a2d9570b44c655bf3165e8d8613d4">souffle::ast::analysis::getGroundedTerms</a></div><div class="ttdeci">std::map&lt; const Argument *, bool &gt; getGroundedTerms(const TranslationUnit &amp;tu, const Clause &amp;clause)</div><div class="ttdoc">Analyse the given clause and computes for each contained argument whether it is a grounded value or n...</div><div class="ttdef"><b>Definition:</b> <a href="_ground_8cpp_source.html#l00278">Ground.cpp:278</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1analysis_html_a1073ec3616e2b1e5628ef038ce21e975"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#a1073ec3616e2b1e5628ef038ce21e975">souffle::ast::analysis::getGreatestCommonSubtypes</a></div><div class="ttdeci">TypeSet getGreatestCommonSubtypes(const Type &amp;a, const Type &amp;b)</div><div class="ttdoc">Computes the greatest common sub types of the two given types.</div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00254">TypeSystem.cpp:254</a></div></div>
<div class="ttc" id="anamespacesouffle_html_aecc08c83ad9634fc515b7aa094702949"><div class="ttname"><a href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">souffle::toString</a></div><div class="ttdeci">const std::string &amp; toString(const std::string &amp;str)</div><div class="ttdoc">A generic function converting strings into strings (trivial case).</div><div class="ttdef"><b>Definition:</b> <a href="_string_util_8h_source.html#l00234">StringUtil.h:234</a></div></div>
<div class="ttc" id="ahtml_js_chartist_min_8h_html_ae5e71a2600e8891c54854be157cc6626"><div class="ttname"><a href="html_js_chartist_min_8h.html#ae5e71a2600e8891c54854be157cc6626">l</a></div><div class="ttdeci">var l</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="anamespacesouffle_html_adea839071e91666e99dedc870a42941c"><div class="ttname"><a href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a></div><div class="ttdeci">auto clone(const std::vector&lt; A * &gt; &amp;xs)</div><div class="ttdef"><b>Definition:</b> <a href="_container_util_8h_source.html#l00172">ContainerUtil.h:172</a></div></div>
<div class="ttc" id="ajson11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00663">json11.h:663</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1analysis_html_a3f0faa30c5f8af5d43f9b888018f7cc5"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#a3f0faa30c5f8af5d43f9b888018f7cc5">souffle::ast::analysis::isOfRootType</a></div><div class="ttdeci">bool isOfRootType(const Type &amp;type, const Type &amp;root)</div><div class="ttdoc">Determines whether the given type is a sub-type of the given root type.</div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00155">TypeSystem.cpp:155</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_html_af59ed6a7c649aec10999baea2f2c8b35"><div class="ttname"><a href="namespacesouffle_1_1ast.html#af59ed6a7c649aec10999baea2f2c8b35">souffle::ast::getRelation</a></div><div class="ttdeci">Relation * getRelation(const Program &amp;program, const QualifiedName &amp;name)</div><div class="ttdoc">Returns the relation with the given name in the program.</div><div class="ttdef"><b>Definition:</b> <a href="_utils_8cpp_source.html#l00101">Utils.cpp:101</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1analysis_html_a2e435338888fbb0a6cc096f1e699f637"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#a2e435338888fbb0a6cc096f1e699f637">souffle::ast::analysis::getVariablesOutsideAggregate</a></div><div class="ttdeci">std::set&lt; std::string &gt; getVariablesOutsideAggregate(const Clause &amp;clause, const Aggregator &amp;aggregate)</div><div class="ttdoc">Computes the set of variables occurring outside the aggregate.</div><div class="ttdef"><b>Definition:</b> <a href="_aggregate_8cpp_source.html#l00164">Aggregate.cpp:164</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1analysis_html_a82279ed776db311a2251771a38f80dbe"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#a82279ed776db311a2251771a38f80dbe">souffle::ast::analysis::getTypeAttribute</a></div><div class="ttdeci">TypeAttribute getTypeAttribute(const Type &amp;type)</div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00353">TypeSystem.cpp:353</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1analysis_html_a7a59a824c8f1a160e57decfc92341203"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#a7a59a824c8f1a160e57decfc92341203">souffle::ast::analysis::isSubtypeOf</a></div><div class="ttdeci">bool isSubtypeOf(const Type &amp;a, const Type &amp;b)</div><div class="ttdoc">Determines whether type a is a subtype of type b.</div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00226">TypeSystem.cpp:226</a></div></div>
<div class="ttc" id="anamespacesouffle_html_a34f8eecb81c090fca9e58d3357b63ed9"><div class="ttname"><a href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">souffle::any_of</a></div><div class="ttdeci">bool any_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether any elements within a container satisfy a certain predicate.</div><div class="ttdef"><b>Definition:</b> <a href="_functional_util_8h_source.html#l00124">FunctionalUtil.h:124</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1analysis_html_ad414b7856462f5965f3bccb58832cd71"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#ad414b7856462f5965f3bccb58832cd71">souffle::ast::analysis::getGreatestCommonSubtypes</a></div><div class="ttdeci">TypeSet getGreatestCommonSubtypes(const TypeSet &amp;a, const TypeSet &amp;b)</div><div class="ttdoc">The set of pair-wise greatest common sub types of the types in the two given sets.</div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00311">TypeSystem.cpp:311</a></div></div>
<div class="ttc" id="anamespacesouffle_html_a6e9757564e85959db8b14a9be7d544e1"><div class="ttname"><a href="namespacesouffle.html#a6e9757564e85959db8b14a9be7d544e1">souffle::which</a></div><div class="ttdeci">std::string which(const std::string &amp;name)</div><div class="ttdoc">Simple implementation of a which tool.</div><div class="ttdef"><b>Definition:</b> <a href="_file_util_8h_source.html#l00104">FileUtil.h:104</a></div></div>
<div class="ttc" id="anamespacesouffle_html_a14b5f9eb9ec09c40e558b242e75de872"><div class="ttname"><a href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">souffle::all_of</a></div><div class="ttdeci">bool all_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether all elements within a container satisfy a certain predicate.</div><div class="ttdef"><b>Definition:</b> <a href="_functional_util_8h_source.html#l00110">FunctionalUtil.h:110</a></div></div>
<div class="ttc" id="ahtml_js_chartist_min_8h_html_a4cb409b8fe88d81ab7faab0d1bbb878d"><div class="ttname"><a href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a></div><div class="ttdeci">l j a showGridBackground &amp;&amp;c b raw series this eventEmitter b</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdef"><b>Definition:</b> <a href="_brie_8h_source.html#l03053">Brie.h:3053</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1analysis_html_a9db4a30b81cfeab00fdbe334526fb30e"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#a9db4a30b81cfeab00fdbe334526fb30e">souffle::ast::analysis::findUniqueVariableName</a></div><div class="ttdeci">std::string findUniqueVariableName(const Clause &amp;clause, std::string base)</div><div class="ttdoc">Find a variable name using base to form a string like base1 Use this when you need to limit the scope...</div><div class="ttdef"><b>Definition:</b> <a href="_aggregate_8cpp_source.html#l00179">Aggregate.cpp:179</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1analysis_html_aca099ea2c9cb2081b6295b0e58cc6e58"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#aca099ea2c9cb2081b6295b0e58cc6e58">souffle::ast::analysis::getTypeAttribute</a></div><div class="ttdeci">std::optional&lt; TypeAttribute &gt; getTypeAttribute(const TypeSet &amp;type)</div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00363">TypeSystem.cpp:363</a></div></div>
<div class="ttc" id="anamespacesouffle_html_a315141918c39611929a694840f046fb5"><div class="ttname"><a href="namespacesouffle.html#a315141918c39611929a694840f046fb5">souffle::fatal</a></div><div class="ttdeci">void fatal(const char *format, const Args &amp;... args)</div><div class="ttdef"><b>Definition:</b> <a href="_misc_util_8h_source.html#l00198">MiscUtil.h:198</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_html_a0bf6b9bdf0a8866bd27dde18442ab43d"><div class="ttname"><a href="namespacesouffle_1_1ast.html#a0bf6b9bdf0a8866bd27dde18442ab43d">souffle::ast::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const Node &amp;root, Visitor&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="ast_2utility_2_visitor_8h_source.html#l00273">Visitor.h:273</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1analysis_html_a0992f547add4896b9f5e220c3d945449"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#a0992f547add4896b9f5e220c3d945449">souffle::ast::analysis::isSubtypeOf</a></div><div class="ttdeci">static TypeConstraint isSubtypeOf(const TypeVar &amp;variable, const Type &amp;type)</div><div class="ttdoc">A constraint factory ensuring that all the types associated to the variable a are subtypes of type b.</div><div class="ttdef"><b>Definition:</b> <a href="_type_constraints_8cpp_source.html#l00035">TypeConstraints.cpp:35</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1analysis_html_a1b1ecaed9c14b785760d185d1274a57b"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#a1b1ecaed9c14b785760d185d1274a57b">souffle::ast::analysis::TypeVar</a></div><div class="ttdeci">ConstraintAnalysisVar&lt; type_lattice &gt; TypeVar</div><div class="ttdoc">The definition of the type of variable to be utilized in the type analysis.</div><div class="ttdef"><b>Definition:</b> <a href="_type_constraints_8h_source.html#l00072">TypeConstraints.h:72</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1analysis_html_ac7dcac078836134ae4e1e59e4d3148e3"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#ac7dcac078836134ae4e1e59e4d3148e3">souffle::ast::analysis::getWitnessVariables</a></div><div class="ttdeci">std::set&lt; std::string &gt; getWitnessVariables(const TranslationUnit &amp;tu, const Clause &amp;clause, const Aggregator &amp;aggregate)</div><div class="ttdoc">Computes the set of witness variables that are used in the aggregate A variable is a witness if it oc...</div><div class="ttdef"><b>Definition:</b> <a href="_aggregate_8cpp_source.html#l00075">Aggregate.cpp:75</a></div></div>
<div class="ttc" id="anamespacestd_html_a280bb9672ba7155b3b7e01895fa39eaf"><div class="ttname"><a href="namespacestd.html#a280bb9672ba7155b3b7e01895fa39eaf">std::type</a></div><div class="ttdeci">ElementType type</div><div class="ttdef"><b>Definition:</b> <a href="span_8h_source.html#l00640">span.h:640</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1analysis_html_abbc7e3bf641dffe8a8dd0db3a8b44712"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#abbc7e3bf641dffe8a8dd0db3a8b44712">souffle::ast::analysis::getInjectedVariables</a></div><div class="ttdeci">std::set&lt; std::string &gt; getInjectedVariables(const TranslationUnit &amp;tu, const Clause &amp;clause, const Aggregator &amp;aggregate)</div><div class="ttdoc">Given an aggregate and a clause, we find all the variables that have been injected into the aggregate...</div><div class="ttdef"><b>Definition:</b> <a href="_aggregate_8cpp_source.html#l00205">Aggregate.cpp:205</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
