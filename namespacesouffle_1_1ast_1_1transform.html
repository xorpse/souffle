<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>souffle: souffle::ast::transform Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">souffle
   &#160;<span id="projectnumber">2.0.2-371-g6315b36</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesouffle.html">souffle</a></li><li class="navelem"><a class="el" href="namespacesouffle_1_1ast.html">ast</a></li><li class="navelem"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html">transform</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">souffle::ast::transform Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacesouffle_1_1ast_1_1transform_1_1test"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform_1_1test.html">test</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_add_nullaries_to_atomless_aggregates_transformer.html">AddNullariesToAtomlessAggregatesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to add artificial nullary atom (+Tautology()) to aggregate bodies that have no atoms.  <a href="classsouffle_1_1ast_1_1transform_1_1_add_nullaries_to_atomless_aggregates_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_component_checker.html">ComponentChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_component_instantiation_transformer.html">ComponentInstantiationTransformer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_conditional_transformer.html">ConditionalTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_transformer.html">Transformer</a> that executes a sub-transformer iff a condition holds.  <a href="classsouffle_1_1ast_1_1transform_1_1_conditional_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_debug_reporter.html">DebugReporter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass which wraps another transformation pass and generates a debug report section for the stage after applying the wrapped transformer, and adds it to the translation unit's debug report.  <a href="classsouffle_1_1ast_1_1transform_1_1_debug_reporter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_execution_plan_checker.html">ExecutionPlanChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_fixpoint_transformer.html">FixpointTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_transformer.html">Transformer</a> that repeatedly executes a sub-transformer until no changes are made.  <a href="classsouffle_1_1ast_1_1transform_1_1_fixpoint_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_fold_anonymous_records.html">FoldAnonymousRecords</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass that removes (binary) constraints on the anonymous records.  <a href="classsouffle_1_1ast_1_1transform_1_1_fold_anonymous_records.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_grounded_terms_checker.html">GroundedTermsChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_ground_witnesses_transformer.html">GroundWitnessesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a grounding so that the witness of a selection aggregate (min/max) can be transferred to the outer scope.  <a href="classsouffle_1_1ast_1_1transform_1_1_ground_witnesses_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_inline_relations_transformer.html">InlineRelationsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to inline marked relations.  <a href="classsouffle_1_1ast_1_1transform_1_1_inline_relations_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_i_o_attributes_transformer.html">IOAttributesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to set attribute names and types in IO operations.  <a href="classsouffle_1_1ast_1_1transform_1_1_i_o_attributes_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_i_o_defaults_transformer.html">IODefaultsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to set defaults for IO operations.  <a href="classsouffle_1_1ast_1_1transform_1_1_i_o_defaults_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer.html">MagicSetTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magic Set Transformation.  <a href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html">MaterializeAggregationQueriesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to create artificial relations for bodies of aggregation functions consisting of more than a single atom.  <a href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_materialize_singleton_aggregation_transformer.html">MaterializeSingletonAggregationTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces literals containing single-valued aggregates with a synthesised relation.  <a href="classsouffle_1_1ast_1_1transform_1_1_materialize_singleton_aggregation_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_meta_transformer.html">MetaTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_transformer.html">Transformer</a> that coordinates other sub-transformations.  <a href="classsouffle_1_1ast_1_1transform_1_1_meta_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_minimise_program_transformer.html">MinimiseProgramTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to remove equivalent rules.  <a href="classsouffle_1_1ast_1_1transform_1_1_minimise_program_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_name_unnamed_variables_transformer.html">NameUnnamedVariablesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to replace unnamed variables with singletons.  <a href="classsouffle_1_1ast_1_1transform_1_1_name_unnamed_variables_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_normalise_multi_result_functors_transformer.html">NormaliseMultiResultFunctorsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniquely names all appearances of ranges.  <a href="classsouffle_1_1ast_1_1transform_1_1_normalise_multi_result_functors_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html">NullableVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_null_transformer.html">NullTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_transformer.html">Transformer</a> that does absolutely nothing.  <a href="classsouffle_1_1ast_1_1transform_1_1_null_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_partition_body_literals_transformer.html">PartitionBodyLiteralsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to move literals into new clauses if they are independent of remaining literals.  <a href="classsouffle_1_1ast_1_1transform_1_1_partition_body_literals_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_pipeline_transformer.html">PipelineTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_transformer.html">Transformer</a> that holds an arbitrary number of sub-transformations.  <a href="classsouffle_1_1ast_1_1transform_1_1_pipeline_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_pragma_checker.html">PragmaChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_provenance_transformer.html">ProvenanceTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to add provenance information.  <a href="classsouffle_1_1ast_1_1transform_1_1_provenance_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_reduce_existentials_transformer.html">ReduceExistentialsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to reduce unnecessary computation for relations that only appear in the form A(_,...,_).  <a href="classsouffle_1_1ast_1_1transform_1_1_reduce_existentials_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_remove_boolean_constraints_transformer.html">RemoveBooleanConstraintsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to remove constant boolean constraints Should be called after any transformation that may generate boolean constraints.  <a href="classsouffle_1_1ast_1_1transform_1_1_remove_boolean_constraints_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_remove_empty_relations_transformer.html">RemoveEmptyRelationsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to remove all empty relations and rules that use empty relations.  <a href="classsouffle_1_1ast_1_1transform_1_1_remove_empty_relations_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_remove_redundant_relations_transformer.html">RemoveRedundantRelationsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to remove relations which are redundant (do not contribute to output).  <a href="classsouffle_1_1ast_1_1transform_1_1_remove_redundant_relations_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_remove_redundant_sums_transformer.html">RemoveRedundantSumsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to remove expressions of the form sum k : { ...  <a href="classsouffle_1_1ast_1_1transform_1_1_remove_redundant_sums_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_remove_relation_copies_transformer.html">RemoveRelationCopiesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to replaces copy of relations by their origin.  <a href="classsouffle_1_1ast_1_1transform_1_1_remove_relation_copies_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_reorder_literals_transformer.html">ReorderLiteralsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to reorder body literals.  <a href="classsouffle_1_1ast_1_1transform_1_1_reorder_literals_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_replace_singleton_variables_transformer.html">ReplaceSingletonVariablesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to replace singleton variables with unnamed variables.  <a href="classsouffle_1_1ast_1_1transform_1_1_replace_singleton_variables_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_resolve_aliases_transformer.html">ResolveAliasesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to eliminate grounded aliases.  <a href="classsouffle_1_1ast_1_1transform_1_1_resolve_aliases_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_resolve_anonymous_record_aliases_transformer.html">ResolveAnonymousRecordAliasesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_transformer.html">Transformer</a> resolving aliases for anonymous records.  <a href="classsouffle_1_1ast_1_1transform_1_1_resolve_anonymous_record_aliases_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_semantic_checker.html">SemanticChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1ast_1_1transform_1_1_semantic_checker_impl.html">SemanticCheckerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_simplify_aggregate_target_expression_transformer.html">SimplifyAggregateTargetExpressionTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to rename aggregation variables to make them unique.  <a href="classsouffle_1_1ast_1_1transform_1_1_simplify_aggregate_target_expression_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_transformer.html">Transformer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_type_checker.html">TypeChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_type_checker_impl.html">TypeCheckerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_type_declaration_checker.html">TypeDeclarationChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_unique_aggregation_variables_transformer.html">UniqueAggregationVariablesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to rename aggregation variables to make them unique.  <a href="classsouffle_1_1ast_1_1transform_1_1_unique_aggregation_variables_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_while_transformer.html">WhileTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_transformer.html">Transformer</a> that repeatedly executes a sub-transformer while a condition is met.  <a href="classsouffle_1_1ast_1_1transform_1_1_while_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aafc4054efc0e769b1385963bf830d75f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#aafc4054efc0e769b1385963bf830d75f">AdornDatabaseTransformer</a> = <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer_1_1_adorn_database_transformer.html">MagicSetTransformer::AdornDatabaseTransformer</a></td></tr>
<tr class="separator:aafc4054efc0e769b1385963bf830d75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d30a0f8d1f00d134b2f58ae8843098"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a97d30a0f8d1f00d134b2f58ae8843098">LabelDatabaseTransformer</a> = <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer_1_1_label_database_transformer.html">MagicSetTransformer::LabelDatabaseTransformer</a></td></tr>
<tr class="separator:a97d30a0f8d1f00d134b2f58ae8843098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c27240d9be3b306720863323de1f102"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a7c27240d9be3b306720863323de1f102">MagicSetCoreTransformer</a> = <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer_1_1_magic_set_core_transformer.html">MagicSetTransformer::MagicSetCoreTransformer</a></td></tr>
<tr class="separator:a7c27240d9be3b306720863323de1f102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ef705a60cce5c75183e88c6ea91b1a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a79ef705a60cce5c75183e88c6ea91b1a">NegativeLabellingTransformer</a> = <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer_1_1_label_database_transformer_1_1_negative_labelling_transformer.html">MagicSetTransformer::LabelDatabaseTransformer::NegativeLabellingTransformer</a></td></tr>
<tr class="separator:a79ef705a60cce5c75183e88c6ea91b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c611874c21ab0a0a32c7075d2a870c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#ab7c611874c21ab0a0a32c7075d2a870c">NormaliseDatabaseTransformer</a> = <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer_1_1_normalise_database_transformer.html">MagicSetTransformer::NormaliseDatabaseTransformer</a></td></tr>
<tr class="separator:ab7c611874c21ab0a0a32c7075d2a870c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312eead19e3697247f19dfe1a0bf1f90"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a312eead19e3697247f19dfe1a0bf1f90">PositiveLabellingTransformer</a> = <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer_1_1_label_database_transformer_1_1_positive_labelling_transformer.html">MagicSetTransformer::LabelDatabaseTransformer::PositiveLabellingTransformer</a></td></tr>
<tr class="separator:a312eead19e3697247f19dfe1a0bf1f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a82a6c6c43a0014cd5c333f52169e38ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a82a6c6c43a0014cd5c333f52169e38ed">combineAggregators</a> (std::vector&lt; <a class="el" href="classsouffle_1_1ast_1_1_aggregator.html">Aggregator</a> * &gt; aggrs, std::string fun)</td></tr>
<tr class="separator:a82a6c6c43a0014cd5c333f52169e38ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee21dc1693bea38bbc8cf4447f27012"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a4ee21dc1693bea38bbc8cf4447f27012">combineNegatedLiterals</a> (std::vector&lt; std::vector&lt; <a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a> * &gt;&gt; litGroups)</td></tr>
<tr class="memdesc:a4ee21dc1693bea38bbc8cf4447f27012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the negated version of a disjunction of conjunctions.  <a href="namespacesouffle_1_1ast_1_1transform.html#a4ee21dc1693bea38bbc8cf4447f27012">More...</a><br /></td></tr>
<tr class="separator:a4ee21dc1693bea38bbc8cf4447f27012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2b2e6f9ed8feb3adfbfbfe43b96dda"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#adc2b2e6f9ed8feb3adfbfbfe43b96dda">containsInlinedAtom</a> (const <a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;program, const <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;clause)</td></tr>
<tr class="memdesc:adc2b2e6f9ed8feb3adfbfbfe43b96dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a given clause contains an atom that should be inlined.  <a href="namespacesouffle_1_1ast_1_1transform.html#adc2b2e6f9ed8feb3adfbfbfe43b96dda">More...</a><br /></td></tr>
<tr class="separator:adc2b2e6f9ed8feb3adfbfbfe43b96dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab750d18fe838e77f89370c6bf7d820"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classsouffle_1_1ast_1_1_qualified_name.html">QualifiedName</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a5ab750d18fe838e77f89370c6bf7d820">findInlineCycle</a> (const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_precedence_graph_analysis.html">PrecedenceGraphAnalysis</a> &amp;precedenceGraph, std::map&lt; const <a class="el" href="classsouffle_1_1ast_1_1_relation.html">Relation</a> *, const <a class="el" href="classsouffle_1_1ast_1_1_relation.html">Relation</a> * &gt; &amp;origins, const <a class="el" href="classsouffle_1_1ast_1_1_relation.html">Relation</a> *current, <a class="el" href="namespacesouffle_1_1ast.html#a91b7228545d71d053324a666e48a528c">RelationSet</a> &amp;unvisited, <a class="el" href="namespacesouffle_1_1ast.html#a91b7228545d71d053324a666e48a528c">RelationSet</a> &amp;visiting, <a class="el" href="namespacesouffle_1_1ast.html#a91b7228545d71d053324a666e48a528c">RelationSet</a> &amp;visited)</td></tr>
<tr class="memdesc:a5ab750d18fe838e77f89370c6bf7d820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a cycle consisting entirely of inlined relations.  <a href="namespacesouffle_1_1ast_1_1transform.html#a5ab750d18fe838e77f89370c6bf7d820">More...</a><br /></td></tr>
<tr class="separator:a5ab750d18fe838e77f89370c6bf7d820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7455cc2262cc907c15e6124ac6588a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a8a7455cc2262cc907c15e6124ac6588a">formNegatedLiterals</a> (<a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;program, <a class="el" href="classsouffle_1_1ast_1_1_atom.html">Atom</a> *atom)</td></tr>
<tr class="memdesc:a8a7455cc2262cc907c15e6124ac6588a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the bodies that will replace the negation of a given inlined atom.  <a href="namespacesouffle_1_1ast_1_1transform.html#a8a7455cc2262cc907c15e6124ac6588a">More...</a><br /></td></tr>
<tr class="separator:a8a7455cc2262cc907c15e6124ac6588a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78e04494a4e67eb9ae63a399c99d92f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html">NullableVector</a>&lt; <a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f">getInlinedArgument</a> (<a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;program, const <a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> *arg)</td></tr>
<tr class="memdesc:ac78e04494a4e67eb9ae63a399c99d92f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of arguments that should replace the given argument after one step of inlining.  <a href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f">More...</a><br /></td></tr>
<tr class="separator:ac78e04494a4e67eb9ae63a399c99d92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbf430b3cb758d9345bb1ba0dd17efd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html">NullableVector</a>&lt; <a class="el" href="classsouffle_1_1ast_1_1_atom.html">Atom</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#addbf430b3cb758d9345bb1ba0dd17efd">getInlinedAtom</a> (<a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;program, <a class="el" href="classsouffle_1_1ast_1_1_atom.html">Atom</a> &amp;atom)</td></tr>
<tr class="memdesc:addbf430b3cb758d9345bb1ba0dd17efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of atoms that should replace the given atom after one step of inlining.  <a href="namespacesouffle_1_1ast_1_1transform.html#addbf430b3cb758d9345bb1ba0dd17efd">More...</a><br /></td></tr>
<tr class="separator:addbf430b3cb758d9345bb1ba0dd17efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0249ff1a6616f955f319df5ffdfaae41"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a0249ff1a6616f955f319df5ffdfaae41">getInlinedClause</a> (<a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;program, const <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;clause)</td></tr>
<tr class="memdesc:a0249ff1a6616f955f319df5ffdfaae41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of clauses that should replace the given clause after one step of inlining.  <a href="namespacesouffle_1_1ast_1_1transform.html#a0249ff1a6616f955f319df5ffdfaae41">More...</a><br /></td></tr>
<tr class="separator:a0249ff1a6616f955f319df5ffdfaae41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d908235c9c6d168bdfb2098b55090e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html">NullableVector</a>&lt; std::vector&lt; <a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a60d908235c9c6d168bdfb2098b55090e">getInlinedLiteral</a> (<a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;program, <a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a> *lit)</td></tr>
<tr class="memdesc:a60d908235c9c6d168bdfb2098b55090e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to perform a single step of inlining on the given literal.  <a href="namespacesouffle_1_1ast_1_1transform.html#a60d908235c9c6d168bdfb2098b55090e">More...</a><br /></td></tr>
<tr class="separator:a60d908235c9c6d168bdfb2098b55090e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce47150ce3942c816dc5d8286f3ee23"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html">NullableVector</a>&lt; <a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a> * &gt;, std::vector&lt; <a class="el" href="classsouffle_1_1ast_1_1_binary_constraint.html">BinaryConstraint</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a3ce47150ce3942c816dc5d8286f3ee23">inlineBodyLiterals</a> (<a class="el" href="classsouffle_1_1ast_1_1_atom.html">Atom</a> *atom, <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> *atomInlineClause)</td></tr>
<tr class="memdesc:a3ce47150ce3942c816dc5d8286f3ee23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlines the given atom based on a given clause.  <a href="namespacesouffle_1_1ast_1_1transform.html#a3ce47150ce3942c816dc5d8286f3ee23">More...</a><br /></td></tr>
<tr class="separator:a3ce47150ce3942c816dc5d8286f3ee23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357d4c2dfac82f7f140b6b03b00d3a2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#a767cede450719b5b1633f12b038c7d61">Own</a>&lt; <a class="el" href="classsouffle_1_1ast_1_1_relation.html">Relation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a357d4c2dfac82f7f140b6b03b00d3a2c">makeInfoRelation</a> (<a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;originalClause, size_t originalClauseNum, <a class="el" href="classsouffle_1_1ast_1_1_translation_unit.html">TranslationUnit</a> &amp;translationUnit)</td></tr>
<tr class="separator:a357d4c2dfac82f7f140b6b03b00d3a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae013df7b43e604d0cbe81322c8a11dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1ast_1_1_qualified_name.html">QualifiedName</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#aae013df7b43e604d0cbe81322c8a11dc">makeRelationName</a> (const <a class="el" href="classsouffle_1_1ast_1_1_qualified_name.html">QualifiedName</a> &amp;orig, const std::string &amp;type, int num=-1)</td></tr>
<tr class="memdesc:aae013df7b43e604d0cbe81322c8a11dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functions.  <a href="namespacesouffle_1_1ast_1_1transform.html#aae013df7b43e604d0cbe81322c8a11dc">More...</a><br /></td></tr>
<tr class="separator:aae013df7b43e604d0cbe81322c8a11dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae484a45044de39fe908c7877109f1f28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#ae484a45044de39fe908c7877109f1f28">nameInlinedUnderscores</a> (<a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;program)</td></tr>
<tr class="memdesc:ae484a45044de39fe908c7877109f1f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all underscores in all atoms of inlined relations.  <a href="namespacesouffle_1_1ast_1_1transform.html#ae484a45044de39fe908c7877109f1f28">More...</a><br /></td></tr>
<tr class="separator:ae484a45044de39fe908c7877109f1f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940bd55ad10e760454fb7af87c1c130d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a940bd55ad10e760454fb7af87c1c130d">negateLiteral</a> (<a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a> *lit)</td></tr>
<tr class="memdesc:a940bd55ad10e760454fb7af87c1c130d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the negated version of a given literal.  <a href="namespacesouffle_1_1ast_1_1transform.html#a940bd55ad10e760454fb7af87c1c130d">More...</a><br /></td></tr>
<tr class="separator:a940bd55ad10e760454fb7af87c1c130d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3f1620e075f934204ecb8e7414c9ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#aff3f1620e075f934204ecb8e7414c9ec">normaliseInlinedHeads</a> (<a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;program)</td></tr>
<tr class="memdesc:aff3f1620e075f934204ecb8e7414c9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace constants in the head of inlined clauses with (constrained) variables.  <a href="namespacesouffle_1_1ast_1_1transform.html#aff3f1620e075f934204ecb8e7414c9ec">More...</a><br /></td></tr>
<tr class="separator:aff3f1620e075f934204ecb8e7414c9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc33cde145c8603d71c83eed4672c1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#abfc33cde145c8603d71c83eed4672c1f">reduceSubstitution</a> (std::vector&lt; std::pair&lt; <a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> *, <a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> * &gt;&gt; &amp;sub)</td></tr>
<tr class="memdesc:abfc33cde145c8603d71c83eed4672c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces a vector of substitutions.  <a href="namespacesouffle_1_1ast_1_1transform.html#abfc33cde145c8603d71c83eed4672c1f">More...</a><br /></td></tr>
<tr class="separator:abfc33cde145c8603d71c83eed4672c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1211fcf1fa30273559973f585502c936"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a1211fcf1fa30273559973f585502c936">renameVariables</a> (<a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> *arg)</td></tr>
<tr class="memdesc:a1211fcf1fa30273559973f585502c936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renames all variables in a given argument uniquely.  <a href="namespacesouffle_1_1ast_1_1transform.html#a1211fcf1fa30273559973f585502c936">More...</a><br /></td></tr>
<tr class="separator:a1211fcf1fa30273559973f585502c936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b86d43c262e724277436f7f829a4fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a00b86d43c262e724277436f7f829a4fb">transformEqrelRelation</a> (<a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;program, <a class="el" href="classsouffle_1_1ast_1_1_relation.html">Relation</a> &amp;<a class="el" href="_tui_8h.html#afb01ff7ecf303cdcd8f713643f605b77">rel</a>)</td></tr>
<tr class="memdesc:a00b86d43c262e724277436f7f829a4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform eqrel relations to explicitly define equivalence relations.  <a href="namespacesouffle_1_1ast_1_1transform.html#a00b86d43c262e724277436f7f829a4fb">More...</a><br /></td></tr>
<tr class="separator:a00b86d43c262e724277436f7f829a4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef7394d84d020c597cb916fa67ff8ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html">NullableVector</a>&lt; std::pair&lt; <a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> *, <a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a4ef7394d84d020c597cb916fa67ff8ed">unifyAtoms</a> (<a class="el" href="classsouffle_1_1ast_1_1_atom.html">Atom</a> *first, <a class="el" href="classsouffle_1_1ast_1_1_atom.html">Atom</a> *second)</td></tr>
<tr class="memdesc:a4ef7394d84d020c597cb916fa67ff8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nullable vector of substitutions needed to unify the two given atoms.  <a href="namespacesouffle_1_1ast_1_1transform.html#a4ef7394d84d020c597cb916fa67ff8ed">More...</a><br /></td></tr>
<tr class="separator:a4ef7394d84d020c597cb916fa67ff8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8494f3003162a166742bb226a9e97d4a"><td class="memItemLeft" align="right" valign="top">static const std::vector&lt; <a class="el" href="classsouffle_1_1_src_location.html">SrcLocation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a8494f3003162a166742bb226a9e97d4a">usesInvalidWitness</a> (<a class="el" href="classsouffle_1_1ast_1_1_translation_unit.html">TranslationUnit</a> &amp;tu, const <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;clause, const <a class="el" href="classsouffle_1_1ast_1_1_aggregator.html">Aggregator</a> &amp;aggregate)</td></tr>
<tr class="memdesc:a8494f3003162a166742bb226a9e97d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A witness is considered "invalid" if it is trying to export a witness out of a count, sum, or mean aggregate.  <a href="namespacesouffle_1_1ast_1_1transform.html#a8494f3003162a166742bb226a9e97d4a">More...</a><br /></td></tr>
<tr class="separator:a8494f3003162a166742bb226a9e97d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aafc4054efc0e769b1385963bf830d75f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc4054efc0e769b1385963bf830d75f">&#9670;&nbsp;</a></span>AdornDatabaseTransformer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesouffle_1_1ast_1_1transform.html#aafc4054efc0e769b1385963bf830d75f">souffle::ast::transform::AdornDatabaseTransformer</a> = typedef <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer_1_1_adorn_database_transformer.html">MagicSetTransformer::AdornDatabaseTransformer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00062">62</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

</div>
</div>
<a id="a97d30a0f8d1f00d134b2f58ae8843098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d30a0f8d1f00d134b2f58ae8843098">&#9670;&nbsp;</a></span>LabelDatabaseTransformer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a97d30a0f8d1f00d134b2f58ae8843098">souffle::ast::transform::LabelDatabaseTransformer</a> = typedef <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer_1_1_label_database_transformer.html">MagicSetTransformer::LabelDatabaseTransformer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00061">61</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

</div>
</div>
<a id="a7c27240d9be3b306720863323de1f102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c27240d9be3b306720863323de1f102">&#9670;&nbsp;</a></span>MagicSetCoreTransformer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a7c27240d9be3b306720863323de1f102">souffle::ast::transform::MagicSetCoreTransformer</a> = typedef <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer_1_1_magic_set_core_transformer.html">MagicSetTransformer::MagicSetCoreTransformer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00063">63</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

</div>
</div>
<a id="a79ef705a60cce5c75183e88c6ea91b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ef705a60cce5c75183e88c6ea91b1a">&#9670;&nbsp;</a></span>NegativeLabellingTransformer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a79ef705a60cce5c75183e88c6ea91b1a">souffle::ast::transform::NegativeLabellingTransformer</a> = typedef <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer_1_1_label_database_transformer_1_1_negative_labelling_transformer.html">MagicSetTransformer::LabelDatabaseTransformer::NegativeLabellingTransformer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00066">66</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

</div>
</div>
<a id="ab7c611874c21ab0a0a32c7075d2a870c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c611874c21ab0a0a32c7075d2a870c">&#9670;&nbsp;</a></span>NormaliseDatabaseTransformer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesouffle_1_1ast_1_1transform.html#ab7c611874c21ab0a0a32c7075d2a870c">souffle::ast::transform::NormaliseDatabaseTransformer</a> = typedef <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer_1_1_normalise_database_transformer.html">MagicSetTransformer::NormaliseDatabaseTransformer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00060">60</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

</div>
</div>
<a id="a312eead19e3697247f19dfe1a0bf1f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a312eead19e3697247f19dfe1a0bf1f90">&#9670;&nbsp;</a></span>PositiveLabellingTransformer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a312eead19e3697247f19dfe1a0bf1f90">souffle::ast::transform::PositiveLabellingTransformer</a> = typedef <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer_1_1_label_database_transformer_1_1_positive_labelling_transformer.html">MagicSetTransformer::LabelDatabaseTransformer::PositiveLabellingTransformer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00068">68</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a82a6c6c43a0014cd5c333f52169e38ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a6c6c43a0014cd5c333f52169e38ed">&#9670;&nbsp;</a></span>combineAggregators()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a>* souffle::ast::transform::combineAggregators </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsouffle_1_1ast_1_1_aggregator.html">Aggregator</a> * &gt;&#160;</td>
          <td class="paramname"><em>aggrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00521">521</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;                                                                                    {</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_inline_relations_8cpp_source.html#l00543">getInlinedArgument()</a>.</p>

</div>
</div>
<a id="a4ee21dc1693bea38bbc8cf4447f27012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee21dc1693bea38bbc8cf4447f27012">&#9670;&nbsp;</a></span>combineNegatedLiterals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a>*&gt; &gt; souffle::ast::transform::combineNegatedLiterals </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a> * &gt;&gt;&#160;</td>
          <td class="paramname"><em>litGroups</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the negated version of a disjunction of conjunctions. </p>
<p>E.g. (a1(x) ^ a2(x) ^ ...) v (b1(x) ^ b2(x) ^ ...) &ndash;into-&gt; (!a1(x) ^ !b1(x)) v (!a2(x) ^ !b2(x)) v ... </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00385">385</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;                               {</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;        <span class="comment">// !(a1 ^ a2 ^ a3 ^ ...) --into-&gt; !a1 v !a2 v !a3 v ...</span></div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> : litGroup) {</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;            std::vector&lt;Literal*&gt; newVec;</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;            newVec.push_back(<a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a940bd55ad10e760454fb7af87c1c130d">negateLiteral</a>(<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>));</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;            negation.push_back(newVec);</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;        }</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160; </div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;        <span class="comment">// Done!</span></div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;        <span class="keywordflow">return</span> negation;</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;    }</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160; </div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;    <span class="comment">// Produce the negated versions of all disjunctions ignoring the first recursively</span></div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;    std::vector&lt;std::vector&lt;Literal*&gt;&gt; combinedRHS = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a4ee21dc1693bea38bbc8cf4447f27012">combineNegatedLiterals</a>(</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;            std::vector&lt;std::vector&lt;Literal*&gt;&gt;(litGroups.begin() + 1, litGroups.end()));</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160; </div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;    <span class="comment">// We now just need to add the negation of a single literal from the untouched LHS</span></div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;    <span class="comment">// to every single conjunction on the RHS to finalise creating every possible combination</span></div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;    <span class="keywordflow">for</span> (Literal* lhsLit : litGroup) {</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;        <span class="keywordflow">for</span> (std::vector&lt;Literal*&gt; rhsVec : combinedRHS) {</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;            std::vector&lt;Literal*&gt; newVec;</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;            newVec.push_back(<a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a940bd55ad10e760454fb7af87c1c130d">negateLiteral</a>(lhsLit));</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160; </div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;            <span class="keywordflow">for</span> (Literal* lit : rhsVec) {</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;                newVec.push_back(lit-&gt;clone());</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;            }</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160; </div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;            negation.push_back(newVec);</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;        }</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;    }</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160; </div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;    <span class="keywordflow">for</span> (std::vector&lt;Literal*&gt; rhsVec : combinedRHS) {</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;        <span class="keywordflow">for</span> (Literal* lit : rhsVec) {</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;            <span class="keyword">delete</span> lit;</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;        }</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    }</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160; </div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;    <span class="keywordflow">return</span> negation;</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;}</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;<span class="comment"> * Forms the bodies that will replace the negation of a given inlined atom.</span></div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;<span class="comment"> * E.g. a(x) &lt;- (a11(x), a12(x)) ; (a21(x), a22(x)) =&gt; !a(x) &lt;- (!a11(x), !a21(x)) ; (!a11(x), !a22(x)) ; ...</span></div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;<span class="comment"> * Essentially, produce every combination (m_1 ^ m_2 ^ ...) where m_i is the negation of a literal in the</span></div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;<span class="comment"> * ith rule of a.</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="adc2b2e6f9ed8feb3adfbfbfe43b96dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2b2e6f9ed8feb3adfbfbfe43b96dda">&#9670;&nbsp;</a></span>containsInlinedAtom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::ast::transform::containsInlinedAtom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;&#160;</td>
          <td class="paramname"><em>clause</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a given clause contains an atom that should be inlined. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00202">202</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;                                                                       {</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5ab750d18fe838e77f89370c6bf7d820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab750d18fe838e77f89370c6bf7d820">&#9670;&nbsp;</a></span>findInlineCycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classsouffle_1_1ast_1_1_qualified_name.html">QualifiedName</a>&gt; souffle::ast::transform::findInlineCycle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_precedence_graph_analysis.html">PrecedenceGraphAnalysis</a> &amp;&#160;</td>
          <td class="paramname"><em>precedenceGraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; const <a class="el" href="classsouffle_1_1ast_1_1_relation.html">Relation</a> *, const <a class="el" href="classsouffle_1_1ast_1_1_relation.html">Relation</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>origins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_relation.html">Relation</a> *&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesouffle_1_1ast.html#a91b7228545d71d053324a666e48a528c">RelationSet</a> &amp;&#160;</td>
          <td class="paramname"><em>unvisited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesouffle_1_1ast.html#a91b7228545d71d053324a666e48a528c">RelationSet</a> &amp;&#160;</td>
          <td class="paramname"><em>visiting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesouffle_1_1ast.html#a91b7228545d71d053324a666e48a528c">RelationSet</a> &amp;&#160;</td>
          <td class="paramname"><em>visited</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a cycle consisting entirely of inlined relations. </p>
<p>If no cycle exists, then an empty vector is returned. </p>

<p class="definition">Definition at line <a class="el" href="_semantic_checker_8cpp_source.html#l00713">713</a> of file <a class="el" href="_semantic_checker_8cpp_source.html">SemanticChecker.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;                               {</div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;            <span class="comment">// Nothing left to visit - so no cycles exist!</span></div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;            <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;        }</div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160; </div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;        <span class="comment">// Choose any element from the unvisited set</span></div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;        current = *unvisited.begin();</div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;        origins[current] = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160; </div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;        <span class="comment">// Move it to &quot;currently visiting&quot;</span></div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;        unvisited.erase(current);</div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;        visiting.insert(current);</div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160; </div>
<div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;        <span class="comment">// Check if we can find a cycle beginning from this node</span></div>
<div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;        std::vector&lt;QualifiedName&gt; subresult =</div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;                <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a5ab750d18fe838e77f89370c6bf7d820">findInlineCycle</a>(precedenceGraph, origins, current, unvisited, visiting, visited);</div>
<div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160; </div>
<div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;        <span class="keywordflow">if</span> (subresult.empty()) {</div>
<div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;            <span class="comment">// No cycle found, try again from another node</span></div>
<div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a5ab750d18fe838e77f89370c6bf7d820">findInlineCycle</a>(precedenceGraph, origins, <span class="keyword">nullptr</span>, unvisited, visiting, visited);</div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;        } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;            <span class="comment">// Cycle found! Return it</span></div>
<div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;            <span class="keywordflow">return</span> subresult;</div>
<div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;        }</div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;    }</div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160; </div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;    <span class="comment">// Check neighbours</span></div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;    <span class="keyword">const</span> <a class="code" href="namespacesouffle_1_1ast.html#a91b7228545d71d053324a666e48a528c">RelationSet</a>&amp; successors = precedenceGraph.graph().successors(current);</div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> Relation* successor : successors) {</div>
<div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;        <span class="comment">// Only care about inlined neighbours in the graph</span></div>
<div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;        <span class="keywordflow">if</span> (successor-&gt;hasQualifier(RelationQualifier::INLINE)) {</div>
<div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;            <span class="keywordflow">if</span> (visited.find(successor) != visited.end()) {</div>
<div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;                <span class="comment">// The neighbour has already been visited, so move on</span></div>
<div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;                <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;            }</div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160; </div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;            <span class="keywordflow">if</span> (visiting.find(successor) != visiting.end()) {</div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;                <span class="comment">// Found a cycle!!</span></div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;                <span class="comment">// Construct the cycle in reverse</span></div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;                <span class="keywordflow">while</span> (current != <span class="keyword">nullptr</span>) {</div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;                    result.push_back(current-&gt;getQualifiedName());</div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;                    current = origins[current];</div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;                }</div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;                <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;            }</div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160; </div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;            <span class="comment">// Node has not been visited yet</span></div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;            origins[successor] = current;</div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160; </div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;            <span class="comment">// Move from unvisited to visiting</span></div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;            unvisited.erase(successor);</div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;            visiting.insert(successor);</div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160; </div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;            <span class="comment">// Visit recursively and check if a cycle is formed</span></div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;            std::vector&lt;QualifiedName&gt; subgraphCycle =</div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;                    <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a5ab750d18fe838e77f89370c6bf7d820">findInlineCycle</a>(precedenceGraph, origins, successor, unvisited, visiting, visited);</div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160; </div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;            <span class="keywordflow">if</span> (!subgraphCycle.empty()) {</div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;                <span class="comment">// Found a cycle!</span></div>
<div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;                <span class="keywordflow">return</span> subgraphCycle;</div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;            }</div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;        }</div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;    }</div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160; </div>
<div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;    <span class="comment">// Visited all neighbours with no cycle found, so done visiting this node.</span></div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;    visiting.erase(current);</div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;    visited.insert(current);</div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;    <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;}</div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160; </div>
<div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;<span class="keywordtype">void</span> SemanticCheckerImpl::checkInlining() {</div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;    <span class="keyword">auto</span> isInline = [&amp;](<span class="keyword">const</span> Relation* <a class="code" href="_tui_8h.html#afb01ff7ecf303cdcd8f713643f605b77">rel</a>) { <span class="keywordflow">return</span> <a class="code" href="_tui_8h.html#afb01ff7ecf303cdcd8f713643f605b77">rel</a>-&gt;hasQualifier(RelationQualifier::INLINE); };</div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160; </div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;    <span class="comment">// Find all inlined relations</span></div>
<div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;    <a class="code" href="namespacesouffle_1_1ast.html#a91b7228545d71d053324a666e48a528c">RelationSet</a> inlinedRelations;</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8a7455cc2262cc907c15e6124ac6588a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7455cc2262cc907c15e6124ac6588a">&#9670;&nbsp;</a></span>formNegatedLiterals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a>*&gt; &gt; souffle::ast::transform::formNegatedLiterals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_atom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>atom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forms the bodies that will replace the negation of a given inlined atom. </p>
<p>E.g. a(x) &lt;- (a11(x), a12(x)) ; (a21(x), a22(x)) =&gt; !a(x) &lt;- (!a11(x), !a21(x)) ; (!a11(x), !a22(x)) ; ... Essentially, produce every combination (m_1 ^ m_2 ^ ...) where m_i is the negation of a literal in the ith rule of a. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00440">440</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;                          : <a class="code" href="namespacesouffle_1_1ast.html#a4aa067ee069beebb52dff5ee7250fc5f">getClauses</a>(program, *<a class="code" href="namespacesouffle_1_1ast.html#af59ed6a7c649aec10999baea2f2c8b35">getRelation</a>(program, atom-&gt;getQualifiedName()))) {</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;        <span class="comment">// Form the replacement clause by inlining based on the current clause</span></div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;        std::pair&lt;NullableVector&lt;Literal*&gt;, std::vector&lt;BinaryConstraint*&gt;&gt; inlineResult =</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;                <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a3ce47150ce3942c816dc5d8286f3ee23">inlineBodyLiterals</a>(atom, inClause);</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;        NullableVector&lt;Literal*&gt; replacementBodyLiterals = inlineResult.first;</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;        std::vector&lt;BinaryConstraint*&gt; currConstraints = inlineResult.second;</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160; </div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;        <span class="keywordflow">if</span> (!replacementBodyLiterals.isValid()) {</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;            <span class="comment">// Failed to unify, so just move on</span></div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;            <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;        }</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160; </div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;        addedBodyLiterals.push_back(replacementBodyLiterals.getVector());</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;        addedConstraints.push_back(currConstraints);</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;    }</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160; </div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;    <span class="comment">// We now have a list of bodies needed to inline the given atom.</span></div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;    <span class="comment">// We want to inline the negated version, however, which is done using De Morgan&#39;s Law.</span></div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    std::vector&lt;std::vector&lt;Literal*&gt;&gt; negatedAddedBodyLiterals = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a4ee21dc1693bea38bbc8cf4447f27012">combineNegatedLiterals</a>(addedBodyLiterals);</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160; </div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;    <span class="comment">// Add in the necessary constraints to all the body literals</span></div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; negatedAddedBodyLiteral : negatedAddedBodyLiterals) {</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;        <span class="keywordflow">for</span> (std::vector&lt;BinaryConstraint*&gt; constraintGroup : addedConstraints) {</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;            <span class="keywordflow">for</span> (BinaryConstraint* constraint : constraintGroup) {</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;                negatedAddedBodyLiteral.push_back(constraint-&gt;clone());</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;            }</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;        }</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;    }</div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160; </div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;    <span class="comment">// Free up the old body literals and constraints</span></div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;    <span class="keywordflow">for</span> (std::vector&lt;Literal*&gt; litGroup : addedBodyLiterals) {</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;        <span class="keywordflow">for</span> (Literal* lit : litGroup) {</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;            <span class="keyword">delete</span> lit;</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;        }</div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;    }</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;    <span class="keywordflow">for</span> (std::vector&lt;BinaryConstraint*&gt; consGroup : addedConstraints) {</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;        <span class="keywordflow">for</span> (Constraint* cons : consGroup) {</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;            <span class="keyword">delete</span> cons;</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;        }</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;    }</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160; </div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;    <span class="keywordflow">return</span> negatedAddedBodyLiterals;</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;}</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;<span class="comment"> * Renames all variables in a given argument uniquely.</span></div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;<span class="keywordtype">void</span> <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a1211fcf1fa30273559973f585502c936">renameVariables</a>(Argument* arg) {</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">int</span> varCount = 0;</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_inline_relations_8cpp_source.html#l00304">inlineBodyLiterals()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_1_1ast_1_1transform_a8a7455cc2262cc907c15e6124ac6588a_cgraph.png" border="0" usemap="#namespacesouffle_1_1ast_1_1transform_a8a7455cc2262cc907c15e6124ac6588a_cgraph" alt=""/></div>
<map name="namespacesouffle_1_1ast_1_1transform_a8a7455cc2262cc907c15e6124ac6588a_cgraph" id="namespacesouffle_1_1ast_1_1transform_a8a7455cc2262cc907c15e6124ac6588a_cgraph">
<area shape="rect" title="Forms the bodies that will replace the negation of a given inlined atom." alt="" coords="5,5,172,47"/>
<area shape="rect" href="namespacesouffle_1_1ast_1_1transform.html#a3ce47150ce3942c816dc5d8286f3ee23" title="Inlines the given atom based on a given clause." alt="" coords="220,5,387,47"/>
</map>
</div>

</div>
</div>
<a id="ac78e04494a4e67eb9ae63a399c99d92f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac78e04494a4e67eb9ae63a399c99d92f">&#9670;&nbsp;</a></span>getInlinedArgument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html">NullableVector</a>&lt;<a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a>*&gt; souffle::ast::transform::getInlinedArgument </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of arguments that should replace the given argument after one step of inlining. </p>
<p>Note: This function is currently generalised to perform any required inlining within aggregators as well, making it simple to extend to this later on if desired (and the semantic check is removed). </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00543">543</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;                                                                 {</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;        <span class="comment">// First try inlining the target expression if necessary</span></div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;        <span class="keywordflow">if</span> (aggr-&gt;getTargetExpression() != <span class="keyword">nullptr</span>) {</div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;            NullableVector&lt;Argument*&gt; argumentVersions =</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;                    <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f">getInlinedArgument</a>(program, aggr-&gt;getTargetExpression());</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160; </div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;            <span class="keywordflow">if</span> (argumentVersions.isValid()) {</div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;                <span class="comment">// An element in the target expression can be inlined!</span></div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;                changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160; </div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;                <span class="comment">// Create a new aggregator per version of the target expression</span></div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;                <span class="keywordflow">for</span> (Argument* newArg : argumentVersions.getVector()) {</div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;                    <span class="keyword">auto</span>* newAggr = <span class="keyword">new</span> Aggregator(aggr-&gt;getBaseOperator(), Own&lt;Argument&gt;(newArg));</div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;                    VecOwn&lt;Literal&gt; newBody;</div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;                    <span class="keywordflow">for</span> (Literal* lit : aggr-&gt;getBodyLiterals()) {</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;                        newBody.push_back(<a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a>(lit));</div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;                    }</div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;                    newAggr-&gt;setBody(std::move(newBody));</div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;                    versions.push_back(newAggr);</div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;                }</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;            }</div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;        }</div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160; </div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;        <span class="comment">// Try inlining body arguments if the target expression has not been changed.</span></div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;        <span class="comment">// (At this point we only handle one step of inlining at a time)</span></div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;        <span class="keywordflow">if</span> (!changed) {</div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;            std::vector&lt;Literal*&gt; bodyLiterals = aggr-&gt;getBodyLiterals();</div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; bodyLiterals.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;                Literal* currLit = bodyLiterals[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160; </div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;                NullableVector&lt;std::vector&lt;Literal*&gt;&gt; literalVersions = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a60d908235c9c6d168bdfb2098b55090e">getInlinedLiteral</a>(program, currLit);</div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160; </div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;                <span class="keywordflow">if</span> (literalVersions.isValid()) {</div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;                    <span class="comment">// Literal can be inlined!</span></div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;                    changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160; </div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;                    <a class="code" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21">AggregateOp</a> op = aggr-&gt;getBaseOperator();</div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160; </div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;                    <span class="comment">// Create an aggregator (with the same operation) for each possible body</span></div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;                    std::vector&lt;Aggregator*&gt; aggrVersions;</div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;                    <span class="keywordflow">for</span> (std::vector&lt;Literal*&gt; inlineVersions : literalVersions.getVector()) {</div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;                        Own&lt;Argument&gt; target;</div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;                        <span class="keywordflow">if</span> (aggr-&gt;getTargetExpression() != <span class="keyword">nullptr</span>) {</div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;                            target = <a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a>(aggr-&gt;getTargetExpression());</div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;                        }</div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;                        <span class="keyword">auto</span>* newAggr = <span class="keyword">new</span> Aggregator(aggr-&gt;getBaseOperator(), std::move(target));</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160; </div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;                        VecOwn&lt;Literal&gt; newBody;</div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;                        <span class="comment">// Add in everything except the current literal being replaced</span></div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;                        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> = 0; <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> &lt; bodyLiterals.size(); <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>++) {</div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;                            <span class="keywordflow">if</span> (<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> != <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>) {</div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;                                newBody.push_back(<a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a>(bodyLiterals[<a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>]));</div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;                            }</div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;                        }</div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160; </div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;                        <span class="comment">// Add in everything new that replaces that literal</span></div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;                        <span class="keywordflow">for</span> (Literal* addedLit : inlineVersions) {</div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;                            newBody.push_back(Own&lt;Literal&gt;(addedLit));</div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;                        }</div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160; </div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;                        newAggr-&gt;setBody(std::move(newBody));</div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;                        aggrVersions.push_back(newAggr);</div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;                    }</div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160; </div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;                    <span class="comment">// Utility lambda: get functor used to tie aggregators together.</span></div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;                    <span class="keyword">auto</span> aggregateToFunctor = [](<a class="code" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21">AggregateOp</a> op) {</div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;                        <span class="keywordflow">switch</span> (op) {</div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::MIN:</div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::FMIN:</div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::UMIN: <span class="keywordflow">return</span> <span class="stringliteral">&quot;min&quot;</span>;</div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::MAX:</div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::FMAX:</div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::UMAX: <span class="keywordflow">return</span> <span class="stringliteral">&quot;max&quot;</span>;</div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::SUM:</div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::FSUM:</div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::USUM:</div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::COUNT: <span class="keywordflow">return</span> <span class="stringliteral">&quot;+&quot;</span>;</div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::MEAN: <a class="code" href="namespacesouffle.html#a315141918c39611929a694840f046fb5">fatal</a>(<span class="stringliteral">&quot;no translation&quot;</span>);</div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;                        }</div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160; </div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;                        <a class="code" href="_misc_util_8h.html#a80064103b41e5e72405c38edf202af56">UNREACHABLE_BAD_CASE_ANALYSIS</a></div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;                    };</div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;                    <span class="comment">// Create the actual overall aggregator that ties the replacement aggregators together.</span></div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;                    <span class="comment">// example: min x : { a(x) }. &lt;=&gt; min ( min x : { a1(x) }, min x : { a2(x) }, ... )</span></div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;                    <span class="keywordflow">if</span> (op != AggregateOp::MEAN) {</div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;                        versions.push_back(<a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a82a6c6c43a0014cd5c333f52169e38ed">combineAggregators</a>(aggrVersions, aggregateToFunctor(op)));</div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;                    }</div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;                }</div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160; </div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;                <span class="comment">// Only perform one stage of inlining at a time.</span></div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;                <span class="keywordflow">if</span> (changed) {</div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;                    <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;                }</div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;            }</div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;        }</div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* functor = <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span>Functor*<span class="keyword">&gt;</span>(arg)) {</div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;        <span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0;</div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> funArg : functor-&gt;getArguments()) {</div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;            <span class="comment">// TODO (azreika): use unique pointers</span></div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;            <span class="comment">// try inlining each argument from left to right</span></div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;            NullableVector&lt;Argument*&gt; argumentVersions = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f">getInlinedArgument</a>(program, funArg);</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;            <span class="keywordflow">if</span> (argumentVersions.isValid()) {</div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;                changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;                <span class="keywordflow">for</span> (Argument* newArgVersion : argumentVersions.getVector()) {</div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;                    <span class="comment">// same functor but with new argument version</span></div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;                    VecOwn&lt;Argument&gt; argsCopy;</div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;                    <span class="keywordtype">size_t</span> <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> = 0;</div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;                    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; functorArg : functor-&gt;getArguments()) {</div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;                        <span class="keywordflow">if</span> (<a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> == <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>) {</div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;                            argsCopy.emplace_back(newArgVersion);</div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;                        } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;                            argsCopy.emplace_back(functorArg-&gt;clone());</div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;                        }</div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;                        ++<a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>;</div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;                    }</div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;                    <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* intrFunc = <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span>IntrinsicFunctor*<span class="keyword">&gt;</span>(arg)) {</div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;                        <span class="keyword">auto</span>* newFunctor =</div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;                                <span class="keyword">new</span> IntrinsicFunctor(intrFunc-&gt;getBaseFunctionOp(), std::move(argsCopy));</div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;                        newFunctor-&gt;setSrcLoc(functor-&gt;getSrcLoc());</div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;                        versions.push_back(newFunctor);</div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;                    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* userFunc = <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span>UserDefinedFunctor*<span class="keyword">&gt;</span>(arg)) {</div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;                        <span class="keyword">auto</span>* newFunctor = <span class="keyword">new</span> UserDefinedFunctor(userFunc-&gt;getName(), std::move(argsCopy));</div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;                        newFunctor-&gt;setSrcLoc(userFunc-&gt;getSrcLoc());</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;                        versions.push_back(newFunctor);</div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;                    }</div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;                }</div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;                <span class="comment">// only one step at a time</span></div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;            }</div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;            ++<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;</div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;        }</div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* cast = <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span>ast::TypeCast*<span class="keyword">&gt;</span>(arg)) {</div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;        NullableVector&lt;Argument*&gt; argumentVersions = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f">getInlinedArgument</a>(program, cast-&gt;getValue());</div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;        <span class="keywordflow">if</span> (argumentVersions.isValid()) {</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;            changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;            <span class="keywordflow">for</span> (Argument* newArg : argumentVersions.getVector()) {</div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;                Argument* newTypeCast = <span class="keyword">new</span> ast::TypeCast(Own&lt;Argument&gt;(newArg), cast-&gt;getType());</div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;                versions.push_back(newTypeCast);</div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;            }</div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;        }</div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* record = <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span>RecordInit*<span class="keyword">&gt;</span>(arg)) {</div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;        std::vector&lt;Argument*&gt; recordArguments = record-&gt;getArguments();</div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; recordArguments.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;            Argument* currentRecArg = recordArguments[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;            NullableVector&lt;Argument*&gt; argumentVersions = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f">getInlinedArgument</a>(program, currentRecArg);</div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;            <span class="keywordflow">if</span> (argumentVersions.isValid()) {</div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;                changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;                <span class="keywordflow">for</span> (Argument* newArgumentVersion : argumentVersions.getVector()) {</div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;                    <span class="keyword">auto</span>* newRecordArg = <span class="keyword">new</span> RecordInit();</div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;                    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> = 0; <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> &lt; recordArguments.size(); <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>++) {</div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;                        <span class="keywordflow">if</span> (<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> == <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>) {</div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;                            newRecordArg-&gt;addArgument(Own&lt;Argument&gt;(newArgumentVersion));</div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;                        } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;                            newRecordArg-&gt;addArgument(<a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a>(recordArguments[<a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>]));</div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;                        }</div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;                    }</div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;                    versions.push_back(newRecordArg);</div>
<div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;                }</div>
<div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;            }</div>
<div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160; </div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;            <span class="comment">// Only perform one stage of inlining at a time.</span></div>
<div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;            <span class="keywordflow">if</span> (changed) {</div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;            }</div>
<div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;        }</div>
<div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;    }</div>
<div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160; </div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;    <span class="keywordflow">if</span> (changed) {</div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;        <span class="comment">// Return a valid vector - replacements need to be made!</span></div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;Argument*&gt;(versions);</div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;        <span class="comment">// Return an invalid vector - no inlining has occurred</span></div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;Argument*&gt;();</div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;    }</div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;}</div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;<span class="comment"> * Returns a vector of atoms that should replace the given atom after one step of inlining.</span></div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;<span class="comment"> * Assumes the relation the atom belongs to is not inlined itself.</span></div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;NullableVector&lt;Atom*&gt; <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#addbf430b3cb758d9345bb1ba0dd17efd">getInlinedAtom</a>(Program&amp; program, Atom&amp; atom) {</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_container_util_8h_source.html#l00172">souffle::clone()</a>, <a class="el" href="_inline_relations_8cpp_source.html#l00521">combineAggregators()</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a4905ac9d6a22bdfc1ae096094ce6248d">souffle::COUNT</a>, <a class="el" href="_misc_util_8h_source.html#l00198">souffle::fatal()</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a1e692622d3020e12589d7fb475de73b1">souffle::FMAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21aa188dc14c6a8fb8a3e7204027a3f16e6">souffle::FMIN</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a0645fcc11b74dbdbf2d7501942fa6f6f">souffle::FSUM</a>, <a class="el" href="_inline_relations_8cpp_source.html#l00785">getInlinedLiteral()</a>, <a class="el" href="json11_8h_source.html#l00663">i</a>, <a class="el" href="html_js_chartist_min_8h_source.html#l00015">j</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a26a4b44a837bf97b972628509912b4a5">souffle::MAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a4ea6d1161ea24d7599365f574aff6610">souffle::MEAN</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21ace31e2a082d17e038fcc6e3006166653">souffle::MIN</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a6970bdc2201030b9c03fbdcf3973858a">souffle::SUM</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21adf23c745cc30333029ae3a73cd87c059">souffle::UMAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a925d976d8f961af767954de9f62f40cb">souffle::UMIN</a>, <a class="el" href="_misc_util_8h_source.html#l00206">UNREACHABLE_BAD_CASE_ANALYSIS</a>, and <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21ae6246115490f016a4ecb2604ba5fc2ed">souffle::USUM</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_8cpp_source.html#l00729">getInlinedAtom()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_1_1ast_1_1transform_ac78e04494a4e67eb9ae63a399c99d92f_cgraph.png" border="0" usemap="#namespacesouffle_1_1ast_1_1transform_ac78e04494a4e67eb9ae63a399c99d92f_cgraph" alt=""/></div>
<map name="namespacesouffle_1_1ast_1_1transform_ac78e04494a4e67eb9ae63a399c99d92f_cgraph" id="namespacesouffle_1_1ast_1_1transform_ac78e04494a4e67eb9ae63a399c99d92f_cgraph">
<area shape="rect" title="Returns a vector of arguments that should replace the given argument after one step of inlining." alt="" coords="5,104,172,145"/>
<area shape="rect" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c" title=" " alt="" coords="719,48,828,75"/>
<area shape="rect" href="namespacesouffle_1_1ast_1_1transform.html#a82a6c6c43a0014cd5c333f52169e38ed" title=" " alt="" coords="220,45,387,86"/>
<area shape="rect" href="namespacesouffle.html#a315141918c39611929a694840f046fb5" title=" " alt="" coords="251,111,355,138"/>
<area shape="rect" href="namespacesouffle_1_1ast_1_1transform.html#a60d908235c9c6d168bdfb2098b55090e" title="Tries to perform a single step of inlining on the given literal." alt="" coords="220,213,387,254"/>
<area shape="rect" href="namespacesouffle_1_1ast.html#a4aa067ee069beebb52dff5ee7250fc5f" title="Returns a vector of clauses in the program describing the relation with the given name." alt="" coords="436,170,611,196"/>
<area shape="rect" href="namespacesouffle_1_1ast_1_1transform.html#addbf430b3cb758d9345bb1ba0dd17efd" title="Returns a vector of atoms that should replace the given atom after one step of inlining." alt="" coords="440,104,607,145"/>
<area shape="rect" href="namespacesouffle_1_1ast.html#af59ed6a7c649aec10999baea2f2c8b35" title="Returns the relation with the given name in the program." alt="" coords="435,220,612,247"/>
<area shape="rect" href="namespacesouffle_1_1ast_1_1transform.html#a3ce47150ce3942c816dc5d8286f3ee23" title="Inlines the given atom based on a given clause." alt="" coords="440,272,607,313"/>
<area shape="rect" href="_tui_8h.html#afb01ff7ecf303cdcd8f713643f605b77" title=" " alt="" coords="504,363,543,390"/>
<area shape="rect" href="namespacesouffle_1_1ast.html#a575099d0db1a527134d072d5689b7cbb" title="Removes the set of clauses with the given relation name." alt="" coords="670,154,877,196"/>
<area shape="rect" href="namespacesouffle_1_1ast.html#acf3697d66e4ab6047687c5419bde6917" title="Removes the set of IOs with the given relation name." alt="" coords="660,220,887,247"/>
<area shape="rect" href="classsouffle_1_1ast_1_1_atom.html#ab9a22c7f862012f074559a4061696241" title="Return qualified name." alt="" coords="993,213,1141,254"/>
<area shape="rect" href="namespacesouffle_1_1test.html#a10453085bc4f71f32dcda443d4b3c446" title=" " alt="" coords="702,271,845,298"/>
<area shape="rect" href="namespacesouffle_1_1profile_1_1_tools.html#afe466b09ae5ee2e1c7c64d55a0ae0c21" title=" " alt="" coords="695,322,851,364"/>
<area shape="rect" href="classsouffle_1_1profile_1_1_table.html#ad5808507021b6f9cdd5641aac825f29e" title=" " alt="" coords="989,334,1146,376"/>
<area shape="rect" href="namespacetinyformat.html#a970fd8292e14eb74ba55bafb41017016" title=" " alt="" coords="706,439,841,466"/>
<area shape="rect" href="classsouffle_1_1profile_1_1_table.html#ad4cd261b758bcc2bc223b1b8d9aaa94e" title=" " alt="" coords="695,610,852,652"/>
<area shape="rect" href="namespacetinyformat.html#adc3e74768f0e2204f9f9a726fc07ec61" title=" " alt="" coords="996,426,1139,452"/>
<area shape="rect" href="namespacetinyformat.html#ab7b10973ec89e6601353675a85f99d61" title=" " alt="" coords="1248,400,1452,427"/>
<area shape="rect" href="namespacetinyformat.html#a86ed74eb3ed66a662e96220d877da964" title="Format list of arguments to the stream according to the given format string." alt="" coords="1275,451,1425,478"/>
<area shape="rect" href="namespacetinyformat_1_1detail.html#a9fe547bc617c38498e58c12cce507bec" title=" " alt="" coords="1500,444,1636,485"/>
<area shape="rect" href="classtinyformat_1_1detail_1_1_format_arg.html#acbf435711bbe4a4da7fc81758d7108a9" title=" " alt="" coords="1703,378,1854,420"/>
<area shape="rect" href="namespacetinyformat_1_1detail.html#ad3d636b9f85202b515c8940b7fcb62a6" title=" " alt="" coords="1686,444,1871,485"/>
<area shape="rect" href="namespacetinyformat_1_1detail.html#ab4493739cbfe66bc79867f13f1fdf0db" title=" " alt="" coords="1684,509,1873,550"/>
<area shape="rect" href="namespacetinyformat_1_1detail.html#a67285e0adb9f4164f9fc30a3eb11c771" title=" " alt="" coords="2148,480,2312,521"/>
<area shape="rect" href="namespacetinyformat_1_1detail.html#ae1e94cbdd9e7cf26f17856a1792664e1" title=" " alt="" coords="1921,538,2100,580"/>
<area shape="rect" href="classtinyformat_1_1detail_1_1_format_arg.html#a91b69f66ce9dc8ca2914dce8985d7a1a" title=" " alt="" coords="2162,545,2298,586"/>
<area shape="rect" href="classsouffle_1_1profile_1_1_data_comparator.html#a734aaeddd3c8a7952ac75358d9cdfe5d" title="Sort by copy time." alt="" coords="936,476,1199,503"/>
<area shape="rect" href="classsouffle_1_1profile_1_1_data_comparator.html#a76f98b6d43dc528c8f8bddb3746e8269" title="Sort by ID." alt="" coords="941,527,1194,554"/>
<area shape="rect" href="classsouffle_1_1profile_1_1_data_comparator.html#ac520aeef0437cb4a54c57b83bfc7af82" title="Sort by name." alt="" coords="952,578,1183,620"/>
<area shape="rect" href="classsouffle_1_1profile_1_1_data_comparator.html#af08f9cf841481752c50d2483027f0a07" title="Sort by non&#45;recursive time." alt="" coords="952,644,1183,685"/>
<area shape="rect" href="classsouffle_1_1profile_1_1_data_comparator.html#a286b840ac5b9694c711f384e3edc0914" title="Sort by recursive time." alt="" coords="936,710,1199,736"/>
<area shape="rect" href="classsouffle_1_1profile_1_1_data_comparator.html#a48b1c57f77017e9ae5a301526ca4a438" title="Sort by total time." alt="" coords="952,761,1183,802"/>
<area shape="rect" href="classsouffle_1_1profile_1_1_data_comparator.html#ae89cb5ff565853d5eb8c5a6299f8774a" title="Sort by tuple count." alt="" coords="935,827,1200,854"/>
</map>
</div>

</div>
</div>
<a id="addbf430b3cb758d9345bb1ba0dd17efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbf430b3cb758d9345bb1ba0dd17efd">&#9670;&nbsp;</a></span>getInlinedAtom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html">NullableVector</a>&lt;<a class="el" href="classsouffle_1_1ast_1_1_atom.html">Atom</a>*&gt; souffle::ast::transform::getInlinedAtom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_atom.html">Atom</a> &amp;&#160;</td>
          <td class="paramname"><em>atom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of atoms that should replace the given atom after one step of inlining. </p>
<p>Assumes the relation the atom belongs to is not inlined itself. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00729">729</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;                                                  {</div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;        Argument* arg = arguments[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div>
<div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160; </div>
<div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;        NullableVector&lt;Argument*&gt; argumentVersions = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f">getInlinedArgument</a>(program, arg);</div>
<div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160; </div>
<div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;        <span class="keywordflow">if</span> (argumentVersions.isValid()) {</div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;            <span class="comment">// Argument has replacements</span></div>
<div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;            changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160; </div>
<div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;            <span class="comment">// Create a new atom per new version of the argument</span></div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;            <span class="keywordflow">for</span> (Argument* newArgument : argumentVersions.getVector()) {</div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;                <span class="keyword">auto</span> args = atom.getArguments();</div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;                VecOwn&lt;Argument&gt; newArgs;</div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> = 0; <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> &lt; args.size(); <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>++) {</div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;                    <span class="keywordflow">if</span> (<a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> == <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>) {</div>
<div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;                        newArgs.emplace_back(newArgument);</div>
<div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;                    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;                        newArgs.emplace_back(args[<a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>]-&gt;<a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">clone</a>());</div>
<div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;                    }</div>
<div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;                }</div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;                <span class="keyword">auto</span>* newAtom = <span class="keyword">new</span> Atom(atom.getQualifiedName(), std::move(newArgs), atom.getSrcLoc());</div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;                versions.push_back(newAtom);</div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;            }</div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;        }</div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160; </div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;        <span class="comment">// Only perform one stage of inlining at a time.</span></div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;        <span class="keywordflow">if</span> (changed) {</div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;        }</div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;    }</div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160; </div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;    <span class="keywordflow">if</span> (changed) {</div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;        <span class="comment">// Return a valid vector - replacements need to be made!</span></div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;Atom*&gt;(versions);</div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;        <span class="comment">// Return an invalid vector - no replacements need to be made</span></div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;Atom*&gt;();</div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;    }</div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;}</div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;<span class="comment"> * Tries to perform a single step of inlining on the given literal.</span></div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;<span class="comment"> * Returns a pair of nullable vectors (v, w) such that:</span></div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;<span class="comment"> *    - v is valid if and only if the literal can be directly inlined, whereby it</span></div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;<span class="comment"> *      contains the bodies that replace it</span></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_container_util_8h_source.html#l00172">souffle::clone()</a>, <a class="el" href="_inline_relations_8cpp_source.html#l00543">getInlinedArgument()</a>, <a class="el" href="json11_8h_source.html#l00663">i</a>, and <a class="el" href="html_js_chartist_min_8h_source.html#l00015">j</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_8cpp_source.html#l00785">getInlinedLiteral()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_1_1ast_1_1transform_addbf430b3cb758d9345bb1ba0dd17efd_cgraph.png" border="0" usemap="#namespacesouffle_1_1ast_1_1transform_addbf430b3cb758d9345bb1ba0dd17efd_cgraph" alt=""/></div>
<map name="namespacesouffle_1_1ast_1_1transform_addbf430b3cb758d9345bb1ba0dd17efd_cgraph" id="namespacesouffle_1_1ast_1_1transform_addbf430b3cb758d9345bb1ba0dd17efd_cgraph">
<area shape="rect" title="Returns a vector of atoms that should replace the given atom after one step of inlining." alt="" coords="5,101,172,142"/>
<area shape="rect" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c" title=" " alt="" coords="463,5,573,32"/>
<area shape="rect" href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f" title="Returns a vector of arguments that should replace the given argument after one step of inlining." alt="" coords="220,101,387,142"/>
<area shape="rect" href="namespacesouffle_1_1ast_1_1transform.html#a82a6c6c43a0014cd5c333f52169e38ed" title=" " alt="" coords="435,57,601,98"/>
<area shape="rect" href="namespacesouffle.html#a315141918c39611929a694840f046fb5" title=" " alt="" coords="466,123,570,149"/>
<area shape="rect" href="namespacesouffle_1_1ast_1_1transform.html#a60d908235c9c6d168bdfb2098b55090e" title="Tries to perform a single step of inlining on the given literal." alt="" coords="435,174,601,215"/>
<area shape="rect" href="namespacesouffle_1_1ast.html#a4aa067ee069beebb52dff5ee7250fc5f" title="Returns a vector of clauses in the program describing the relation with the given name." alt="" coords="651,101,825,128"/>
<area shape="rect" href="namespacesouffle_1_1ast.html#af59ed6a7c649aec10999baea2f2c8b35" title="Returns the relation with the given name in the program." alt="" coords="649,152,827,179"/>
<area shape="rect" href="namespacesouffle_1_1ast_1_1transform.html#a3ce47150ce3942c816dc5d8286f3ee23" title="Inlines the given atom based on a given clause." alt="" coords="655,203,821,245"/>
<area shape="rect" href="_tui_8h.html#afb01ff7ecf303cdcd8f713643f605b77" title=" " alt="" coords="719,295,757,321"/>
<area shape="rect" href="namespacesouffle_1_1ast.html#a575099d0db1a527134d072d5689b7cbb" title="Removes the set of clauses with the given relation name." alt="" coords="885,86,1091,127"/>
<area shape="rect" href="namespacesouffle_1_1ast.html#acf3697d66e4ab6047687c5419bde6917" title="Removes the set of IOs with the given relation name." alt="" coords="875,152,1101,179"/>
<area shape="rect" href="classsouffle_1_1ast_1_1_atom.html#ab9a22c7f862012f074559a4061696241" title="Return qualified name." alt="" coords="1208,145,1356,186"/>
<area shape="rect" href="namespacesouffle_1_1test.html#a10453085bc4f71f32dcda443d4b3c446" title=" " alt="" coords="917,203,1059,229"/>
<area shape="rect" href="namespacesouffle_1_1profile_1_1_tools.html#afe466b09ae5ee2e1c7c64d55a0ae0c21" title=" " alt="" coords="910,254,1066,295"/>
<area shape="rect" href="classsouffle_1_1profile_1_1_table.html#ad5808507021b6f9cdd5641aac825f29e" title=" " alt="" coords="1203,266,1361,307"/>
<area shape="rect" href="namespacetinyformat.html#a970fd8292e14eb74ba55bafb41017016" title=" " alt="" coords="921,371,1055,397"/>
<area shape="rect" href="classsouffle_1_1profile_1_1_table.html#ad4cd261b758bcc2bc223b1b8d9aaa94e" title=" " alt="" coords="909,542,1067,583"/>
<area shape="rect" href="namespacetinyformat.html#adc3e74768f0e2204f9f9a726fc07ec61" title=" " alt="" coords="1211,357,1353,384"/>
<area shape="rect" href="namespacetinyformat.html#ab7b10973ec89e6601353675a85f99d61" title=" " alt="" coords="1463,332,1667,359"/>
<area shape="rect" href="namespacetinyformat.html#a86ed74eb3ed66a662e96220d877da964" title="Format list of arguments to the stream according to the given format string." alt="" coords="1489,383,1640,409"/>
<area shape="rect" href="namespacetinyformat_1_1detail.html#a9fe547bc617c38498e58c12cce507bec" title=" " alt="" coords="1715,375,1851,417"/>
<area shape="rect" href="classtinyformat_1_1detail_1_1_format_arg.html#acbf435711bbe4a4da7fc81758d7108a9" title=" " alt="" coords="1918,310,2069,351"/>
<area shape="rect" href="namespacetinyformat_1_1detail.html#ad3d636b9f85202b515c8940b7fcb62a6" title=" " alt="" coords="1901,375,2086,417"/>
<area shape="rect" href="namespacetinyformat_1_1detail.html#ab4493739cbfe66bc79867f13f1fdf0db" title=" " alt="" coords="1899,441,2088,482"/>
<area shape="rect" href="namespacetinyformat_1_1detail.html#a67285e0adb9f4164f9fc30a3eb11c771" title=" " alt="" coords="2363,411,2527,453"/>
<area shape="rect" href="namespacetinyformat_1_1detail.html#ae1e94cbdd9e7cf26f17856a1792664e1" title=" " alt="" coords="2136,470,2315,511"/>
<area shape="rect" href="classtinyformat_1_1detail_1_1_format_arg.html#a91b69f66ce9dc8ca2914dce8985d7a1a" title=" " alt="" coords="2377,477,2513,518"/>
<area shape="rect" href="classsouffle_1_1profile_1_1_data_comparator.html#a734aaeddd3c8a7952ac75358d9cdfe5d" title="Sort by copy time." alt="" coords="1151,408,1413,435"/>
<area shape="rect" href="classsouffle_1_1profile_1_1_data_comparator.html#a76f98b6d43dc528c8f8bddb3746e8269" title="Sort by ID." alt="" coords="1155,459,1409,485"/>
<area shape="rect" href="classsouffle_1_1profile_1_1_data_comparator.html#ac520aeef0437cb4a54c57b83bfc7af82" title="Sort by name." alt="" coords="1167,510,1397,551"/>
<area shape="rect" href="classsouffle_1_1profile_1_1_data_comparator.html#af08f9cf841481752c50d2483027f0a07" title="Sort by non&#45;recursive time." alt="" coords="1167,575,1397,617"/>
<area shape="rect" href="classsouffle_1_1profile_1_1_data_comparator.html#a286b840ac5b9694c711f384e3edc0914" title="Sort by recursive time." alt="" coords="1151,641,1413,668"/>
<area shape="rect" href="classsouffle_1_1profile_1_1_data_comparator.html#a48b1c57f77017e9ae5a301526ca4a438" title="Sort by total time." alt="" coords="1167,693,1397,734"/>
<area shape="rect" href="classsouffle_1_1profile_1_1_data_comparator.html#ae89cb5ff565853d5eb8c5a6299f8774a" title="Sort by tuple count." alt="" coords="1149,759,1415,785"/>
</map>
</div>

</div>
</div>
<a id="a0249ff1a6616f955f319df5ffdfaae41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0249ff1a6616f955f319df5ffdfaae41">&#9670;&nbsp;</a></span>getInlinedClause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a>*&gt; souffle::ast::transform::getInlinedClause </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;&#160;</td>
          <td class="paramname"><em>clause</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of clauses that should replace the given clause after one step of inlining. </p>
<p>If no inlining can occur, the list will only contain a clone of the original clause. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00911">911</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;                                {</div>
<div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;        <span class="comment">// The head atom can be inlined!</span></div>
<div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;        changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160; </div>
<div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;        <span class="comment">// Produce the new clauses with the replacement head atoms</span></div>
<div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;        <span class="keywordflow">for</span> (Atom* newHead : headVersions.getVector()) {</div>
<div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;            <span class="keyword">auto</span>* newClause = <span class="keyword">new</span> Clause();</div>
<div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;            newClause-&gt;setSrcLoc(clause.getSrcLoc());</div>
<div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160; </div>
<div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;            newClause-&gt;setHead(Own&lt;Atom&gt;(newHead));</div>
<div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160; </div>
<div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;            <span class="comment">// The body will remain unchanged</span></div>
<div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;            <span class="keywordflow">for</span> (Literal* lit : clause.getBodyLiterals()) {</div>
<div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;                newClause-&gt;addToBody(<a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a>(lit));</div>
<div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;            }</div>
<div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160; </div>
<div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;            versions.push_back(newClause);</div>
<div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;        }</div>
<div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;    }</div>
<div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160; </div>
<div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;    <span class="comment">// Only perform one stage of inlining at a time.</span></div>
<div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;    <span class="comment">// If the head atoms did not need inlining, try inlining atoms nested in the body.</span></div>
<div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;    <span class="keywordflow">if</span> (!changed) {</div>
<div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;        std::vector&lt;Literal*&gt; bodyLiterals = clause.getBodyLiterals();</div>
<div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; bodyLiterals.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div>
<div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;            Literal* currLit = bodyLiterals[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div>
<div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160; </div>
<div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;            <span class="comment">// Three possible cases when trying to inline a literal:</span></div>
<div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;            <span class="comment">//  1) The literal itself may be directly inlined. In this case, the atom can be replaced</span></div>
<div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;            <span class="comment">//    with multiple different bodies, as the inlined atom may have several rules.</span></div>
<div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;            <span class="comment">//  2) Otherwise, the literal itself may not need to be inlined, but a subnode (e.g. an argument)</span></div>
<div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;            <span class="comment">//    may need to be inlined. In this case, an altered literal must replace the original.</span></div>
<div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;            <span class="comment">//    Again, several possible versions may exist, as the inlined relation may have several rules.</span></div>
<div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;            <span class="comment">//  3) The literal does not depend on any inlined relations, and so does not need to be changed.</span></div>
<div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;            NullableVector&lt;std::vector&lt;Literal*&gt;&gt; litVersions = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a60d908235c9c6d168bdfb2098b55090e">getInlinedLiteral</a>(program, currLit);</div>
<div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160; </div>
<div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;            <span class="keywordflow">if</span> (litVersions.isValid()) {</div>
<div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;                <span class="comment">// Case 1 and 2: Inlining has occurred!</span></div>
<div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;                changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160; </div>
<div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;                <span class="comment">// The literal may be replaced with several different bodies.</span></div>
<div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;                <span class="comment">// Create a new clause for each possible version.</span></div>
<div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;                std::vector&lt;std::vector&lt;Literal*&gt;&gt; bodyVersions = litVersions.getVector();</div>
<div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160; </div>
<div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;                <span class="comment">// Create the base clause with the current literal removed</span></div>
<div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;                <span class="keyword">auto</span> baseClause = Own&lt;Clause&gt;(<a class="code" href="namespacesouffle_1_1ast.html#a29de8c1720372f7c78dcfabe84767118">cloneHead</a>(&amp;clause));</div>
<div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;                <span class="keywordflow">for</span> (Literal* oldLit : bodyLiterals) {</div>
<div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;                    <span class="keywordflow">if</span> (currLit != oldLit) {</div>
<div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;                        baseClause-&gt;addToBody(<a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a>(oldLit));</div>
<div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;                    }</div>
<div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;                }</div>
<div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160; </div>
<div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;                <span class="keywordflow">for</span> (std::vector&lt;Literal*&gt; body : bodyVersions) {</div>
<div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;                    Clause* replacementClause = baseClause-&gt;clone();</div>
<div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160; </div>
<div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;                    <span class="comment">// Add in the current set of literals replacing the inlined literal</span></div>
<div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;                    <span class="comment">// In Case 2, each body contains exactly one literal</span></div>
<div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;                    <span class="keywordflow">for</span> (Literal* newLit : body) {</div>
<div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;                        replacementClause-&gt;addToBody(Own&lt;Literal&gt;(newLit));</div>
<div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;                    }</div>
<div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160; </div>
<div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;                    versions.push_back(replacementClause);</div>
<div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;                }</div>
<div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;            }</div>
<div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160; </div>
<div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;            <span class="comment">// Only replace at most one literal per iteration</span></div>
<div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;            <span class="keywordflow">if</span> (changed) {</div>
<div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;            }</div>
<div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;        }</div>
<div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;    }</div>
<div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160; </div>
<div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;    <span class="keywordflow">if</span> (!changed) {</div>
<div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;        <span class="comment">// Case 3: No inlining changes, so a clone of the original should be returned</span></div>
<div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;        std::vector&lt;Clause*&gt; ret;</div>
<div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;        ret.push_back(clause.clone());</div>
<div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;        <span class="keywordflow">return</span> ret;</div>
<div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;        <span class="comment">// Inlining changes, so return the replacement clauses.</span></div>
<div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;        <span class="keywordflow">return</span> versions;</div>
<div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;    }</div>
<div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;}</div>
<div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160; </div>
<div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;<span class="keywordtype">bool</span> InlineRelationsTransformer::transform(TranslationUnit&amp; translationUnit) {</div>
<div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;    <span class="keywordtype">bool</span> changed = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;    Program&amp; program = translationUnit.getProgram();</div>
<div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160; </div>
<div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;    <span class="comment">// Replace constants in the head of inlined clauses with (constrained) variables.</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a60d908235c9c6d168bdfb2098b55090e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d908235c9c6d168bdfb2098b55090e">&#9670;&nbsp;</a></span>getInlinedLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html">NullableVector</a>&lt; std::vector&lt; <a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a> * &gt; &gt; souffle::ast::transform::getInlinedLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a> *&#160;</td>
          <td class="paramname"><em>lit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to perform a single step of inlining on the given literal. </p>
<p>Returns a pair of nullable vectors (v, w) such that:</p><ul>
<li>v is valid if and only if the literal can be directly inlined, whereby it contains the bodies that replace it</li>
<li>if v is not valid, then w is valid if and only if the literal cannot be inlined directly, but contains a subargument that can be. In this case, it will contain the versions that will replace it.</li>
<li>If both are invalid, then no more inlining can occur on this literal and we are done. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00785">785</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;                                               {</div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;        <span class="comment">// Check if this atom is meant to be inlined</span></div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;        Relation* <a class="code" href="_tui_8h.html#afb01ff7ecf303cdcd8f713643f605b77">rel</a> = <a class="code" href="namespacesouffle_1_1ast.html#af59ed6a7c649aec10999baea2f2c8b35">getRelation</a>(program, atom-&gt;getQualifiedName());</div>
<div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160; </div>
<div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="_tui_8h.html#afb01ff7ecf303cdcd8f713643f605b77">rel</a>-&gt;hasQualifier(RelationQualifier::INLINE)) {</div>
<div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;            <span class="comment">// We found an atom in the clause that needs to be inlined!</span></div>
<div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;            <span class="comment">// The clause needs to be replaced</span></div>
<div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;            inlined = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160; </div>
<div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;            <span class="comment">// N new clauses should be formed, where N is the number of clauses</span></div>
<div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;            <span class="comment">// associated with the inlined relation</span></div>
<div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;            <span class="keywordflow">for</span> (Clause* inClause : <a class="code" href="namespacesouffle_1_1ast.html#a4aa067ee069beebb52dff5ee7250fc5f">getClauses</a>(program, *<a class="code" href="_tui_8h.html#afb01ff7ecf303cdcd8f713643f605b77">rel</a>)) {</div>
<div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;                <span class="comment">// Form the replacement clause</span></div>
<div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;                std::pair&lt;NullableVector&lt;Literal*&gt;, std::vector&lt;BinaryConstraint*&gt;&gt; inlineResult =</div>
<div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;                        <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a3ce47150ce3942c816dc5d8286f3ee23">inlineBodyLiterals</a>(atom, inClause);</div>
<div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;                NullableVector&lt;Literal*&gt; replacementBodyLiterals = inlineResult.first;</div>
<div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;                std::vector&lt;BinaryConstraint*&gt; currConstraints = inlineResult.second;</div>
<div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160; </div>
<div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;                <span class="keywordflow">if</span> (!replacementBodyLiterals.isValid()) {</div>
<div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;                    <span class="comment">// Failed to unify the atoms! We can skip this one...</span></div>
<div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;                    <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;                }</div>
<div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160; </div>
<div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;                <span class="comment">// Unification successful - the returned vector of literals represents one possible body</span></div>
<div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;                <span class="comment">// replacement We can add in the unification constraints as part of these literals.</span></div>
<div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;                std::vector&lt;Literal*&gt; bodyResult = replacementBodyLiterals.getVector();</div>
<div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160; </div>
<div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;                <span class="keywordflow">for</span> (BinaryConstraint* cons : currConstraints) {</div>
<div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;                    bodyResult.push_back(cons);</div>
<div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;                }</div>
<div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160; </div>
<div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;                addedBodyLiterals.push_back(bodyResult);</div>
<div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;            }</div>
<div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;        } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;            <span class="comment">// Not meant to be inlined, but a subargument may be</span></div>
<div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;            NullableVector&lt;Atom*&gt; atomVersions = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#addbf430b3cb758d9345bb1ba0dd17efd">getInlinedAtom</a>(program, *atom);</div>
<div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;            <span class="keywordflow">if</span> (atomVersions.isValid()) {</div>
<div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;                <span class="comment">// Subnode needs to be inlined, so we have a vector of replacement atoms</span></div>
<div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;                changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;                <span class="keywordflow">for</span> (Atom* newAtom : atomVersions.getVector()) {</div>
<div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;                    versions.push_back(newAtom);</div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;                }</div>
<div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;            }</div>
<div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;        }</div>
<div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">auto</span> neg = <span class="keyword">dynamic_cast&lt;</span>Negation*<span class="keyword">&gt;</span>(lit)) {</div>
<div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;        <span class="comment">// For negations, check the corresponding atom</span></div>
<div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;        Atom* atom = neg-&gt;getAtom();</div>
<div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;        NullableVector&lt;std::vector&lt;Literal*&gt;&gt; atomVersions = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a60d908235c9c6d168bdfb2098b55090e">getInlinedLiteral</a>(program, atom);</div>
<div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160; </div>
<div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;        <span class="keywordflow">if</span> (atomVersions.isValid()) {</div>
<div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;            <span class="comment">// The atom can be inlined</span></div>
<div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;            inlined = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160; </div>
<div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;            <span class="keywordflow">if</span> (atomVersions.getVector().empty()) {</div>
<div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;                <span class="comment">// No clauses associated with the atom, so just becomes a true literal</span></div>
<div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;                addedBodyLiterals.push_back({<span class="keyword">new</span> BooleanConstraint(<span class="keyword">true</span>)});</div>
<div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;                <span class="comment">// Suppose an atom a(x) is inlined and has the following rules:</span></div>
<div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;                <span class="comment">//  - a(x) :- a11(x), a12(x).</span></div>
<div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;                <span class="comment">//  - a(x) :- a21(x), a22(x).</span></div>
<div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;                <span class="comment">// Then, a(x) &lt;- (a11(x) ^ a12(x)) v (a21(x) ^ a22(x))</span></div>
<div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;                <span class="comment">//  =&gt; !a(x) &lt;- (!a11(x) v !a12(x)) ^ (!a21(x) v !a22(x))</span></div>
<div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;                <span class="comment">//  =&gt; !a(x) &lt;- (!a11(x) ^ !a21(x)) v (!a11(x) ^ !a22(x)) v ...</span></div>
<div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;                <span class="comment">// Essentially, produce every combination (m_1 ^ m_2 ^ ...) where m_i is a</span></div>
<div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;                <span class="comment">// negated literal in the ith rule of a.</span></div>
<div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;                addedBodyLiterals = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a8a7455cc2262cc907c15e6124ac6588a">formNegatedLiterals</a>(program, atom);</div>
<div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;            }</div>
<div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;        }</div>
<div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;        <span class="keywordflow">if</span> (atomVersions.isValid()) {</div>
<div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; curVec : atomVersions.getVector()) {</div>
<div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span>* cur : curVec) {</div>
<div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;                    <span class="keyword">delete</span> cur;</div>
<div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;                }</div>
<div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;            }</div>
<div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;        }</div>
<div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">auto</span>* constraint = <span class="keyword">dynamic_cast&lt;</span>BinaryConstraint*<span class="keyword">&gt;</span>(lit)) {</div>
<div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;        NullableVector&lt;Argument*&gt; lhsVersions = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f">getInlinedArgument</a>(program, constraint-&gt;getLHS());</div>
<div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;        <span class="keywordflow">if</span> (lhsVersions.isValid()) {</div>
<div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;            changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;            <span class="keywordflow">for</span> (Argument* newLhs : lhsVersions.getVector()) {</div>
<div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;                Literal* newLit = <span class="keyword">new</span> BinaryConstraint(constraint-&gt;getBaseOperator(), Own&lt;Argument&gt;(newLhs),</div>
<div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;                        <a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a>(constraint-&gt;getRHS()));</div>
<div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;                versions.push_back(newLit);</div>
<div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;            }</div>
<div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;        } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;            NullableVector&lt;Argument*&gt; rhsVersions = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f">getInlinedArgument</a>(program, constraint-&gt;getRHS());</div>
<div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;            <span class="keywordflow">if</span> (rhsVersions.isValid()) {</div>
<div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;                changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;                <span class="keywordflow">for</span> (Argument* newRhs : rhsVersions.getVector()) {</div>
<div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;                    Literal* newLit = <span class="keyword">new</span> BinaryConstraint(constraint-&gt;getBaseOperator(),</div>
<div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;                            <a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a>(constraint-&gt;getLHS()), Own&lt;Argument&gt;(newRhs));</div>
<div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;                    versions.push_back(newLit);</div>
<div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;                }</div>
<div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;            }</div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;        }</div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;    }</div>
<div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160; </div>
<div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;    <span class="keywordflow">if</span> (changed) {</div>
<div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;        <span class="comment">// Not inlined directly but found replacement literals</span></div>
<div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;        <span class="comment">// Rewrite these as single-literal bodies</span></div>
<div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;        <span class="keywordflow">for</span> (Literal* version : versions) {</div>
<div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;            std::vector&lt;Literal*&gt; newBody;</div>
<div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;            newBody.push_back(version);</div>
<div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;            addedBodyLiterals.push_back(newBody);</div>
<div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;        }</div>
<div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;        inlined = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;    }</div>
<div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160; </div>
<div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;    <span class="keywordflow">if</span> (inlined) {</div>
<div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;std::vector&lt;Literal*&gt;&gt;(addedBodyLiterals);</div>
<div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;std::vector&lt;Literal*&gt;&gt;();</div>
<div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;    }</div>
<div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;}</div>
<div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;<span class="comment"> * Returns a list of clauses that should replace the given clause after one step of inlining.</span></div>
<div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;<span class="comment"> * If no inlining can occur, the list will only contain a clone of the original clause.</span></div>
<div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;std::vector&lt;Clause*&gt; <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a0249ff1a6616f955f319df5ffdfaae41">getInlinedClause</a>(Program&amp; program, <span class="keyword">const</span> Clause&amp; clause) {</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_utils_8cpp_source.html#l00077">souffle::ast::getClauses()</a>, <a class="el" href="_inline_relations_8cpp_source.html#l00729">getInlinedAtom()</a>, <a class="el" href="_utils_8cpp_source.html#l00101">souffle::ast::getRelation()</a>, <a class="el" href="namespacesouffle.html#a4d1111156440d898474b3cd9cd43a276acfbac07c6ae3e73f0e10ca60ad916bef">souffle::INLINE</a>, <a class="el" href="_inline_relations_8cpp_source.html#l00304">inlineBodyLiterals()</a>, and <a class="el" href="_tui_8h_source.html#l01086">rel()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_8cpp_source.html#l00543">getInlinedArgument()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_1_1ast_1_1transform_a60d908235c9c6d168bdfb2098b55090e_cgraph.png" border="0" usemap="#namespacesouffle_1_1ast_1_1transform_a60d908235c9c6d168bdfb2098b55090e_cgraph" alt=""/></div>
<map name="namespacesouffle_1_1ast_1_1transform_a60d908235c9c6d168bdfb2098b55090e_cgraph" id="namespacesouffle_1_1ast_1_1transform_a60d908235c9c6d168bdfb2098b55090e_cgraph">
<area shape="rect" title="Tries to perform a single step of inlining on the given literal." alt="" coords="5,156,172,197"/>
<area shape="rect" href="namespacesouffle_1_1ast.html#a4aa067ee069beebb52dff5ee7250fc5f" title="Returns a vector of clauses in the program describing the relation with the given name." alt="" coords="221,21,396,47"/>
<area shape="rect" href="namespacesouffle_1_1ast_1_1transform.html#addbf430b3cb758d9345bb1ba0dd17efd" title="Returns a vector of atoms that should replace the given atom after one step of inlining." alt="" coords="225,123,392,164"/>
<area shape="rect" href="namespacesouffle_1_1ast.html#af59ed6a7c649aec10999baea2f2c8b35" title="Returns the relation with the given name in the program." alt="" coords="220,71,397,98"/>
<area shape="rect" href="namespacesouffle_1_1ast_1_1transform.html#a3ce47150ce3942c816dc5d8286f3ee23" title="Inlines the given atom based on a given clause." alt="" coords="225,188,392,229"/>
<area shape="rect" href="_tui_8h.html#afb01ff7ecf303cdcd8f713643f605b77" title=" " alt="" coords="289,365,328,391"/>
<area shape="rect" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c" title=" " alt="" coords="798,130,907,157"/>
<area shape="rect" href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f" title="Returns a vector of arguments that should replace the given argument after one step of inlining." alt="" coords="475,181,642,223"/>
<area shape="rect" href="namespacesouffle_1_1ast_1_1transform.html#a82a6c6c43a0014cd5c333f52169e38ed" title=" " alt="" coords="769,181,936,223"/>
<area shape="rect" href="namespacesouffle.html#a315141918c39611929a694840f046fb5" title=" " alt="" coords="801,247,905,274"/>
<area shape="rect" href="namespacesouffle_1_1ast.html#a575099d0db1a527134d072d5689b7cbb" title="Removes the set of clauses with the given relation name." alt="" coords="455,64,662,105"/>
<area shape="rect" href="namespacesouffle_1_1ast.html#acf3697d66e4ab6047687c5419bde6917" title="Removes the set of IOs with the given relation name." alt="" coords="445,13,672,39"/>
<area shape="rect" href="classsouffle_1_1ast_1_1_atom.html#ab9a22c7f862012f074559a4061696241" title="Return qualified name." alt="" coords="779,5,927,47"/>
<area shape="rect" href="namespacesouffle_1_1test.html#a10453085bc4f71f32dcda443d4b3c446" title=" " alt="" coords="487,598,630,625"/>
<area shape="rect" href="namespacesouffle_1_1profile_1_1_tools.html#afe466b09ae5ee2e1c7c64d55a0ae0c21" title=" " alt="" coords="481,328,637,369"/>
<area shape="rect" href="classsouffle_1_1profile_1_1_table.html#ad5808507021b6f9cdd5641aac825f29e" title=" " alt="" coords="774,299,931,340"/>
<area shape="rect" href="namespacetinyformat.html#a970fd8292e14eb74ba55bafb41017016" title=" " alt="" coords="491,394,626,421"/>
<area shape="rect" href="classsouffle_1_1profile_1_1_table.html#ad4cd261b758bcc2bc223b1b8d9aaa94e" title=" " alt="" coords="480,532,637,573"/>
<area shape="rect" href="namespacetinyformat.html#adc3e74768f0e2204f9f9a726fc07ec61" title=" " alt="" coords="781,365,924,391"/>
<area shape="rect" href="namespacetinyformat.html#ab7b10973ec89e6601353675a85f99d61" title=" " alt="" coords="1033,339,1237,366"/>
<area shape="rect" href="namespacetinyformat.html#a86ed74eb3ed66a662e96220d877da964" title="Format list of arguments to the stream according to the given format string." alt="" coords="1060,390,1211,417"/>
<area shape="rect" href="namespacetinyformat_1_1detail.html#a9fe547bc617c38498e58c12cce507bec" title=" " alt="" coords="1285,383,1421,424"/>
<area shape="rect" href="classtinyformat_1_1detail_1_1_format_arg.html#acbf435711bbe4a4da7fc81758d7108a9" title=" " alt="" coords="1489,317,1639,359"/>
<area shape="rect" href="namespacetinyformat_1_1detail.html#ad3d636b9f85202b515c8940b7fcb62a6" title=" " alt="" coords="1471,383,1657,424"/>
<area shape="rect" href="namespacetinyformat_1_1detail.html#ab4493739cbfe66bc79867f13f1fdf0db" title=" " alt="" coords="1469,448,1659,489"/>
<area shape="rect" href="namespacetinyformat_1_1detail.html#a67285e0adb9f4164f9fc30a3eb11c771" title=" " alt="" coords="1933,419,2097,460"/>
<area shape="rect" href="namespacetinyformat_1_1detail.html#ae1e94cbdd9e7cf26f17856a1792664e1" title=" " alt="" coords="1707,477,1885,519"/>
<area shape="rect" href="classtinyformat_1_1detail_1_1_format_arg.html#a91b69f66ce9dc8ca2914dce8985d7a1a" title=" " alt="" coords="1947,484,2083,525"/>
<area shape="rect" href="classsouffle_1_1profile_1_1_data_comparator.html#a734aaeddd3c8a7952ac75358d9cdfe5d" title="Sort by copy time." alt="" coords="721,766,984,793"/>
<area shape="rect" href="classsouffle_1_1profile_1_1_data_comparator.html#a76f98b6d43dc528c8f8bddb3746e8269" title="Sort by ID." alt="" coords="726,415,979,442"/>
<area shape="rect" href="classsouffle_1_1profile_1_1_data_comparator.html#ac520aeef0437cb4a54c57b83bfc7af82" title="Sort by name." alt="" coords="737,467,968,508"/>
<area shape="rect" href="classsouffle_1_1profile_1_1_data_comparator.html#af08f9cf841481752c50d2483027f0a07" title="Sort by non&#45;recursive time." alt="" coords="737,532,968,573"/>
<area shape="rect" href="classsouffle_1_1profile_1_1_data_comparator.html#a286b840ac5b9694c711f384e3edc0914" title="Sort by recursive time." alt="" coords="721,598,984,625"/>
<area shape="rect" href="classsouffle_1_1profile_1_1_data_comparator.html#a48b1c57f77017e9ae5a301526ca4a438" title="Sort by total time." alt="" coords="737,649,968,691"/>
<area shape="rect" href="classsouffle_1_1profile_1_1_data_comparator.html#ae89cb5ff565853d5eb8c5a6299f8774a" title="Sort by tuple count." alt="" coords="720,715,985,742"/>
</map>
</div>

</div>
</div>
<a id="a3ce47150ce3942c816dc5d8286f3ee23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce47150ce3942c816dc5d8286f3ee23">&#9670;&nbsp;</a></span>inlineBodyLiterals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html">NullableVector</a>&lt;<a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a>*&gt;, std::vector&lt;<a class="el" href="classsouffle_1_1ast_1_1_binary_constraint.html">BinaryConstraint</a>*&gt; &gt; souffle::ast::transform::inlineBodyLiterals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_atom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>atom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> *&#160;</td>
          <td class="paramname"><em>atomInlineClause</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inlines the given atom based on a given clause. </p>
<p>Returns the vector of replacement literals and the necessary constraints. If unification is unsuccessful, the vector of literals is marked as invalid. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00304">304</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;                           : <span class="keyword">public</span> NodeMapper {</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;        <span class="keywordtype">int</span> varnum;</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;        VariableRenamer(<span class="keywordtype">int</span> varnum) : varnum(varnum) {}</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;        Own&lt;Node&gt; operator()(Own&lt;Node&gt; node)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;            <span class="keywordflow">if</span> (<span class="keyword">auto</span>* var = <span class="keyword">dynamic_cast&lt;</span>ast::Variable*<span class="keyword">&gt;</span>(node.get())) {</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;                <span class="comment">// Rename the variable</span></div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;                <span class="keyword">auto</span> newVar = <a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a>(var);</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;                std::stringstream newName;</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;                newName &lt;&lt; <span class="stringliteral">&quot;&lt;inlined_&quot;</span> &lt;&lt; var-&gt;getName() &lt;&lt; <span class="stringliteral">&quot;_&quot;</span> &lt;&lt; varnum &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span>;</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;                newVar-&gt;setName(newName.str());</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;                <span class="keywordflow">return</span> newVar;</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;            }</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;            node-&gt;apply(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;            <span class="keywordflow">return</span> node;</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;        }</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;    };</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160; </div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    VariableRenamer update(inlineCount);</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    atomClause-&gt;apply(update);</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160; </div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;    inlineCount++;</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160; </div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    <span class="comment">// Get the constraints needed to unify the two atoms</span></div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    NullableVector&lt;std::pair&lt;Argument*, Argument*&gt;&gt; res = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a4ef7394d84d020c597cb916fa67ff8ed">unifyAtoms</a>(atomClause-&gt;getHead(), atom);</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    <span class="keywordflow">if</span> (res.isValid()) {</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;        changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;        <span class="keywordflow">for</span> (std::pair&lt;Argument*, Argument*&gt; pair : res.getVector()) {</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;            <span class="comment">// FIXME: float equiv (`FEQ`)</span></div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;            constraints.push_back(<span class="keyword">new</span> BinaryConstraint(</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;                    BinaryConstraintOp::EQ, <a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a>(pair.first), <a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a>(pair.second)));</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;        }</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160; </div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;        <span class="comment">// Add in the body of the current clause of the inlined atom</span></div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;        <span class="keywordflow">for</span> (Literal* lit : atomClause-&gt;getBodyLiterals()) {</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;            addedLits.push_back(lit-&gt;clone());</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;        }</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;    }</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160; </div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;    <span class="keywordflow">if</span> (changed) {</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;        <span class="keywordflow">return</span> std::make_pair(NullableVector&lt;Literal*&gt;(addedLits), constraints);</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;        <span class="keywordflow">return</span> std::make_pair(NullableVector&lt;Literal*&gt;(), constraints);</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;    }</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;}</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;<span class="comment"> * Returns the negated version of a given literal</span></div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;Literal* <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a940bd55ad10e760454fb7af87c1c130d">negateLiteral</a>(Literal* lit) {</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">auto</span>* atom = <span class="keyword">dynamic_cast&lt;</span>Atom*<span class="keyword">&gt;</span>(lit)) {</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_inline_relations_8cpp_source.html#l00440">formNegatedLiterals()</a>, and <a class="el" href="_inline_relations_8cpp_source.html#l00785">getInlinedLiteral()</a>.</p>

</div>
</div>
<a id="a357d4c2dfac82f7f140b6b03b00d3a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357d4c2dfac82f7f140b6b03b00d3a2c">&#9670;&nbsp;</a></span>makeInfoRelation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#a767cede450719b5b1633f12b038c7d61">Own</a>&lt;<a class="el" href="classsouffle_1_1ast_1_1_relation.html">Relation</a>&gt; souffle::ast::transform::makeInfoRelation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;&#160;</td>
          <td class="paramname"><em>originalClause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>originalClauseNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_translation_unit.html">TranslationUnit</a> &amp;&#160;</td>
          <td class="paramname"><em>translationUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_provenance_8cpp_source.html#l00078">78</a> of file <a class="el" href="_provenance_8cpp_source.html">Provenance.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;                                                      {</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        <span class="keywordflow">if</span> (<span class="keyword">auto</span>* var = <span class="keyword">dynamic_cast&lt;</span>ast::Variable*<span class="keyword">&gt;</span>(arg)) {</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a>(*var);</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">auto</span>* constant = <span class="keyword">dynamic_cast&lt;</span>Constant*<span class="keyword">&gt;</span>(arg)) {</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a>(*constant);</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        }</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        <span class="keywordflow">if</span> (isA&lt;UnnamedVariable&gt;(arg)) {</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;_&quot;</span>;</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        }</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;        <span class="keywordflow">if</span> (isA&lt;Functor&gt;(arg)) {</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacetinyformat.html#adc3e74768f0e2204f9f9a726fc07ec61">tfm::format</a>(<span class="stringliteral">&quot;functor_%d&quot;</span>, functorNumber++);</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        }</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        <span class="keywordflow">if</span> (isA&lt;Aggregator&gt;(arg)) {</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacetinyformat.html#adc3e74768f0e2204f9f9a726fc07ec61">tfm::format</a>(<span class="stringliteral">&quot;agg_%d&quot;</span>, aggregateNumber++);</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        }</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160; </div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        <a class="code" href="namespacesouffle.html#a315141918c39611929a694840f046fb5">fatal</a>(<span class="stringliteral">&quot;Unhandled argument type&quot;</span>);</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    };</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160; </div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    <span class="comment">// add head arguments</span></div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; arg : originalClause.getHead()-&gt;getArguments()) {</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        headVariables.push_back(getArgInfo(arg));</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    }</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160; </div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    <span class="comment">// join variables in the head with commas</span></div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    std::stringstream headVariableString;</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    headVariableString &lt;&lt; <a class="code" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb">join</a>(headVariables, <span class="stringliteral">&quot;,&quot;</span>);</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160; </div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    <span class="comment">// add an attribute to infoRelation for the head of clause</span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    infoRelation-&gt;addAttribute(mk&lt;Attribute&gt;(std::string(<span class="stringliteral">&quot;head_vars&quot;</span>), QualifiedName(<span class="stringliteral">&quot;symbol&quot;</span>)));</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    infoClauseHead-&gt;addArgument(mk&lt;StringConstant&gt;(<a class="code" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a>(<a class="code" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb">join</a>(headVariables, <span class="stringliteral">&quot;,&quot;</span>))));</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160; </div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    <span class="comment">// visit all body literals and add to info clause head</span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; originalClause.getBodyLiterals().<a class="code" href="namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail.html#a876af6f91231ae4e7e7316f5402682dc">size</a>(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;        <span class="keyword">auto</span> lit = originalClause.getBodyLiterals()[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160; </div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;        <span class="keyword">const</span> Atom* atom = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;        <span class="keywordflow">if</span> (isA&lt;Atom&gt;(lit)) {</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;            atom = <span class="keyword">static_cast&lt;</span>Atom*<span class="keyword">&gt;</span>(lit);</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isA&lt;Negation&gt;(lit)) {</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;            atom = <span class="keyword">static_cast&lt;</span>Negation*<span class="keyword">&gt;</span>(lit)-&gt;getAtom();</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isA&lt;ProvenanceNegation&gt;(lit)) {</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;            atom = <span class="keyword">static_cast&lt;</span>ProvenanceNegation*<span class="keyword">&gt;</span>(lit)-&gt;getAtom();</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        }</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160; </div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;        <span class="comment">// add an attribute for atoms and binary constraints</span></div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        <span class="keywordflow">if</span> (atom != <span class="keyword">nullptr</span> || isA&lt;BinaryConstraint&gt;(lit)) {</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;            infoRelation-&gt;addAttribute(</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;                    mk&lt;Attribute&gt;(std::string(<span class="stringliteral">&quot;rel_&quot;</span>) + std::to_string(<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>), QualifiedName(<span class="stringliteral">&quot;symbol&quot;</span>)));</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;        }</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160; </div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;        <span class="keywordflow">if</span> (atom != <span class="keyword">nullptr</span>) {</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;            std::string relName = <a class="code" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a>(atom-&gt;getQualifiedName());</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160; </div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;            <span class="comment">// for an atom, add its name and variables (converting aggregates to variables)</span></div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;            <span class="keywordflow">if</span> (isA&lt;Atom&gt;(lit)) {</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;                std::string atomDescription = relName;</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160; </div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; arg : atom-&gt;getArguments()) {</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;                    atomDescription.append(<span class="stringliteral">&quot;,&quot;</span> + getArgInfo(arg));</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;                }</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160; </div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;                infoClauseHead-&gt;addArgument(mk&lt;StringConstant&gt;(atomDescription));</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;                <span class="comment">// for a negation, add a marker with the relation name</span></div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isA&lt;Negation&gt;(lit)) {</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;                infoClauseHead-&gt;addArgument(mk&lt;StringConstant&gt;(<span class="stringliteral">&quot;!&quot;</span> + relName));</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;            }</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;        }</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    }</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160; </div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    <span class="comment">// visit all body constraints and add to info clause head</span></div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; originalClause.getBodyLiterals().<a class="code" href="namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail.html#a876af6f91231ae4e7e7316f5402682dc">size</a>(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;        <span class="keyword">auto</span> lit = originalClause.getBodyLiterals()[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160; </div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;        <span class="keywordflow">if</span> (<span class="keyword">auto</span> con = <span class="keyword">dynamic_cast&lt;</span>BinaryConstraint*<span class="keyword">&gt;</span>(lit)) {</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;            <span class="comment">// for a constraint, add the constraint symbol and LHS and RHS</span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;            std::string constraintDescription = <a class="code" href="namespacesouffle.html#a10525539360588d9c9048cb27f80d6ea">toBinaryConstraintSymbol</a>(con-&gt;getBaseOperator());</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160; </div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;            constraintDescription.append(<span class="stringliteral">&quot;,&quot;</span> + getArgInfo(con-&gt;getLHS()));</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;            constraintDescription.append(<span class="stringliteral">&quot;,&quot;</span> + getArgInfo(con-&gt;getRHS()));</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160; </div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;            infoClauseHead-&gt;addArgument(mk&lt;StringConstant&gt;(constraintDescription));</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;        }</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    }</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160; </div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    infoRelation-&gt;addAttribute(mk&lt;Attribute&gt;(<span class="stringliteral">&quot;clause_repr&quot;</span>, QualifiedName(<span class="stringliteral">&quot;symbol&quot;</span>)));</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    infoClauseHead-&gt;addArgument(mk&lt;StringConstant&gt;(<a class="code" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a>(originalClause)));</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160; </div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    <span class="comment">// set clause head and add clause to info relation</span></div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    infoClause-&gt;setHead(Own&lt;Atom&gt;(infoClauseHead));</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    Program&amp; program = translationUnit.getProgram();</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    program.addClause(Own&lt;Clause&gt;(infoClause));</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160; </div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    <span class="keywordflow">return</span> Own&lt;Relation&gt;(infoRelation);</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;}</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;<span class="comment">/** Transform eqrel relations to explicitly define equivalence relations */</span></div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;<span class="keywordtype">void</span> <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a00b86d43c262e724277436f7f829a4fb">transformEqrelRelation</a>(Program&amp; program, Relation&amp; <a class="code" href="_tui_8h.html#afb01ff7ecf303cdcd8f713643f605b77">rel</a>) {</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    assert(<a class="code" href="_tui_8h.html#afb01ff7ecf303cdcd8f713643f605b77">rel</a>.getRepresentation() == RelationRepresentation::EQREL &amp;&amp;</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;            <span class="stringliteral">&quot;attempting to transform non-eqrel relation&quot;</span>);</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    assert(<a class="code" href="_tui_8h.html#afb01ff7ecf303cdcd8f713643f605b77">rel</a>.getArity() == 2 &amp;&amp; <span class="stringliteral">&quot;eqrel relation not binary&quot;</span>);</div>
</div><!-- fragment -->
</div>
</div>
<a id="aae013df7b43e604d0cbe81322c8a11dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae013df7b43e604d0cbe81322c8a11dc">&#9670;&nbsp;</a></span>makeRelationName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1ast_1_1_qualified_name.html">QualifiedName</a> souffle::ast::transform::makeRelationName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_qualified_name.html">QualifiedName</a> &amp;&#160;</td>
          <td class="paramname"><em>orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper functions. </p>

<p class="definition">Definition at line <a class="el" href="_provenance_8cpp_source.html#l00068">68</a> of file <a class="el" href="_provenance_8cpp_source.html">Provenance.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;                                                                                            {</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    QualifiedName name =</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;            <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#aae013df7b43e604d0cbe81322c8a11dc">makeRelationName</a>(originalClause.getHead()-&gt;getQualifiedName(), <span class="stringliteral">&quot;@info&quot;</span>, originalClauseNum);</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160; </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae484a45044de39fe908c7877109f1f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae484a45044de39fe908c7877109f1f28">&#9670;&nbsp;</a></span>nameInlinedUnderscores()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::ast::transform::nameInlinedUnderscores </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all underscores in all atoms of inlined relations. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00146">146</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;                : inlinedRelations(std::move(inlinedRelations)), replaceUnderscores(replaceUnderscores) {}</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160; </div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;        Own&lt;Node&gt; operator()(Own&lt;Node&gt; node)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;            <span class="keyword">static</span> <span class="keywordtype">int</span> underscoreCount = 0;</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160; </div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;            <span class="keywordflow">if</span> (!replaceUnderscores) {</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;                <span class="comment">// Check if we should start replacing underscores for this node&#39;s subnodes</span></div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;                <span class="keywordflow">if</span> (<span class="keyword">auto</span>* atom = <span class="keyword">dynamic_cast&lt;</span>Atom*<span class="keyword">&gt;</span>(node.get())) {</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;                    <span class="keywordflow">if</span> (inlinedRelations.find(atom-&gt;getQualifiedName()) != inlinedRelations.end()) {</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;                        <span class="comment">// Atom associated with an inlined relation, so replace the underscores</span></div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;                        <span class="comment">// in all of its subnodes with named variables.</span></div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;                        M replace(inlinedRelations, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;                        node-&gt;apply(replace);</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;                        changed |= replace.changed;</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;                        <span class="keywordflow">return</span> node;</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;                    }</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;                }</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isA&lt;UnnamedVariable&gt;(node.get())) {</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;                <span class="comment">// Give a unique name to the underscored variable</span></div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;                <span class="comment">// TODO (azreika): need a more consistent way of handling internally generated variables in</span></div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;                <span class="comment">// general</span></div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;                std::stringstream newVarName;</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;                newVarName &lt;&lt; <span class="stringliteral">&quot;&lt;underscore_&quot;</span> &lt;&lt; underscoreCount++ &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span>;</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;                changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;                <span class="keywordflow">return</span> mk&lt;ast::Variable&gt;(newVarName.str());</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;            }</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160; </div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;            node-&gt;apply(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;            <span class="keywordflow">return</span> node;</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;        }</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    };</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160; </div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    <span class="comment">// Store the names of all relations to be inlined</span></div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    std::set&lt;QualifiedName&gt; inlinedRelations;</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    <span class="keywordflow">for</span> (Relation* <a class="code" href="_tui_8h.html#afb01ff7ecf303cdcd8f713643f605b77">rel</a> : program.getRelations()) {</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="_tui_8h.html#afb01ff7ecf303cdcd8f713643f605b77">rel</a>-&gt;hasQualifier(RelationQualifier::INLINE)) {</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;            inlinedRelations.insert(<a class="code" href="_tui_8h.html#afb01ff7ecf303cdcd8f713643f605b77">rel</a>-&gt;getQualifiedName());</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;        }</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    }</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160; </div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    <span class="comment">// Apply the renaming procedure to the entire program</span></div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    M update(inlinedRelations, <span class="keyword">false</span>);</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    program.apply(update);</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    <span class="keywordflow">return</span> update.changed;</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;}</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;<span class="comment"> * Checks if a given clause contains an atom that should be inlined.</span></div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;<span class="keywordtype">bool</span> <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#adc2b2e6f9ed8feb3adfbfbfe43b96dda">containsInlinedAtom</a>(<span class="keyword">const</span> Program&amp; program, <span class="keyword">const</span> Clause&amp; clause) {</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    <span class="keywordtype">bool</span> foundInlinedAtom = <span class="keyword">false</span>;</div>
</div><!-- fragment -->
</div>
</div>
<a id="a940bd55ad10e760454fb7af87c1c130d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940bd55ad10e760454fb7af87c1c130d">&#9670;&nbsp;</a></span>negateLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a>* souffle::ast::transform::negateLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a> *&#160;</td>
          <td class="paramname"><em>lit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the negated version of a given literal. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00365">365</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;                                                            {</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;        Constraint* newCons = cons-&gt;clone();</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;        <a class="code" href="namespacesouffle_1_1ast.html#aa858fc1ad141e8a9dd2b806407c65116">negateConstraintInPlace</a>(*newCons);</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;        <span class="keywordflow">return</span> newCons;</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;    }</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160; </div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;    <a class="code" href="namespacesouffle.html#a315141918c39611929a694840f046fb5">fatal</a>(<span class="stringliteral">&quot;unsupported literal type: %s&quot;</span>, *lit);</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;}</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;<span class="comment"> * Return the negated version of a disjunction of conjunctions.</span></div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;<span class="comment"> * E.g. (a1(x) ^ a2(x) ^ ...) v (b1(x) ^ b2(x) ^ ...) --into-&gt; (!a1(x) ^ !b1(x)) v (!a2(x) ^ !b2(x)) v ...</span></div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;std::vector&lt;std::vector&lt;Literal*&gt;&gt; <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a4ee21dc1693bea38bbc8cf4447f27012">combineNegatedLiterals</a>(std::vector&lt;std::vector&lt;Literal*&gt;&gt; litGroups) {</div>
</div><!-- fragment -->
</div>
</div>
<a id="aff3f1620e075f934204ecb8e7414c9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3f1620e075f934204ecb8e7414c9ec">&#9670;&nbsp;</a></span>normaliseInlinedHeads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::ast::transform::normaliseInlinedHeads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace constants in the head of inlined clauses with (constrained) variables. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00093">93</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;                                                         {</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;            <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;        }</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160; </div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        <span class="keywordflow">for</span> (Clause* clause : <a class="code" href="namespacesouffle_1_1ast.html#a4aa067ee069beebb52dff5ee7250fc5f">getClauses</a>(program, *<a class="code" href="_tui_8h.html#afb01ff7ecf303cdcd8f713643f605b77">rel</a>)) {</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;            <span class="comment">// Set up the new clause with an empty body and no arguments in the head</span></div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;            <span class="keyword">auto</span> newClause = mk&lt;Clause&gt;();</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;            newClause-&gt;setSrcLoc(clause-&gt;getSrcLoc());</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;            <span class="keyword">auto</span> clauseHead = mk&lt;Atom&gt;(clause-&gt;getHead()-&gt;getQualifiedName());</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160; </div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;            <span class="comment">// Add in everything in the original body</span></div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;            <span class="keywordflow">for</span> (Literal* lit : clause-&gt;getBodyLiterals()) {</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;                newClause-&gt;addToBody(<a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a>(lit));</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;            }</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160; </div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;            <span class="comment">// Set up the head arguments in the new clause</span></div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;            <span class="keywordflow">for</span> (Argument* arg : clause-&gt;getHead()-&gt;getArguments()) {</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;                <span class="keywordflow">if</span> (<span class="keyword">auto</span>* constant = <span class="keyword">dynamic_cast&lt;</span>Constant*<span class="keyword">&gt;</span>(arg)) {</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;                    <span class="comment">// Found a constant in the head, so replace it with a variable</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;                    std::stringstream newVar;</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;                    newVar &lt;&lt; <span class="stringliteral">&quot;&lt;new_var_&quot;</span> &lt;&lt; newVarCount++ &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span>;</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;                    clauseHead-&gt;addArgument(mk&lt;ast::Variable&gt;(newVar.str()));</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160; </div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;                    <span class="comment">// Add a body constraint to set the variable&#39;s value to be the original constant</span></div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;                    newClause-&gt;addToBody(mk&lt;BinaryConstraint&gt;(BinaryConstraintOp::EQ,</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;                            mk&lt;ast::Variable&gt;(newVar.str()), <a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a>(constant)));</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;                    <span class="comment">// Already a variable</span></div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;                    clauseHead-&gt;addArgument(<a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a>(arg));</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;                }</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;            }</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160; </div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;            newClause-&gt;setHead(std::move(clauseHead));</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160; </div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;            <span class="comment">// Replace the old clause with this one</span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;            program.addClause(std::move(newClause));</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;            program.removeClause(clause);</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;            changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;        }</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    }</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160; </div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    <span class="keywordflow">return</span> changed;</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;}</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;<span class="comment"> * Removes all underscores in all atoms of inlined relations</span></div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;<span class="keywordtype">bool</span> <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#ae484a45044de39fe908c7877109f1f28">nameInlinedUnderscores</a>(Program&amp; program) {</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    <span class="keyword">struct </span>M : <span class="keyword">public</span> NodeMapper {</div>
</div><!-- fragment -->
</div>
</div>
<a id="abfc33cde145c8603d71c83eed4672c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc33cde145c8603d71c83eed4672c1f">&#9670;&nbsp;</a></span>reduceSubstitution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::ast::transform::reduceSubstitution </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> *, <a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> * &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>sub</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces a vector of substitutions. </p>
<p>Returns false only if matched argument pairs are found to be incompatible. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00219">219</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;                                                {</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;            <span class="keyword">auto</span> currPair = <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#af454c8b25ece926ca5206774d8f23be1">sub</a>[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;            Argument* <a class="code" href="_resolve_aliases_8cpp.html#aa40661b6cade2b7755921bda0bac0fb4">lhs</a> = currPair.first;</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;            Argument* <a class="code" href="_resolve_aliases_8cpp.html#a4e09535c06791089b6e68d7af597db7a">rhs</a> = currPair.second;</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160; </div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;            <span class="comment">// Start trying to reduce the substitution</span></div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;            <span class="comment">// Note: Can probably go further with this substitution reduction</span></div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;            <span class="keywordflow">if</span> (*<a class="code" href="_resolve_aliases_8cpp.html#aa40661b6cade2b7755921bda0bac0fb4">lhs</a> == *<a class="code" href="_resolve_aliases_8cpp.html#a4e09535c06791089b6e68d7af597db7a">rhs</a>) {</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;                <span class="comment">// Get rid of redundant `x = x`</span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;                <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#af454c8b25ece926ca5206774d8f23be1">sub</a>.erase(<a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#af454c8b25ece926ca5206774d8f23be1">sub</a>.begin() + <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>);</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;                done = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isA&lt;Constant&gt;(<a class="code" href="_resolve_aliases_8cpp.html#aa40661b6cade2b7755921bda0bac0fb4">lhs</a>) &amp;&amp; isA&lt;Constant&gt;(<a class="code" href="_resolve_aliases_8cpp.html#a4e09535c06791089b6e68d7af597db7a">rhs</a>)) {</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;                <span class="comment">// Both are constants but not equal (prev case =&gt; !=)</span></div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;                <span class="comment">// Failed to unify!</span></div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isA&lt;RecordInit&gt;(<a class="code" href="_resolve_aliases_8cpp.html#aa40661b6cade2b7755921bda0bac0fb4">lhs</a>) &amp;&amp; isA&lt;RecordInit&gt;(<a class="code" href="_resolve_aliases_8cpp.html#a4e09535c06791089b6e68d7af597db7a">rhs</a>)) {</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;                <span class="comment">// Note: we will not deal with the case where only one side is</span></div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;                <span class="comment">// a record and the other is a variable, as variables can be records</span></div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;                <span class="comment">// on a deeper level.</span></div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;                std::vector&lt;Argument*&gt; lhsArgs = <span class="keyword">static_cast&lt;</span>RecordInit*<span class="keyword">&gt;</span>(<a class="code" href="_resolve_aliases_8cpp.html#aa40661b6cade2b7755921bda0bac0fb4">lhs</a>)-&gt;getArguments();</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;                std::vector&lt;Argument*&gt; rhsArgs = <span class="keyword">static_cast&lt;</span>RecordInit*<span class="keyword">&gt;</span>(<a class="code" href="_resolve_aliases_8cpp.html#a4e09535c06791089b6e68d7af597db7a">rhs</a>)-&gt;getArguments();</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160; </div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;                <span class="keywordflow">if</span> (lhsArgs.size() != rhsArgs.size()) {</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;                    <span class="comment">// Records of unequal size can&#39;t be equated</span></div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;                }</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160; </div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;                <span class="comment">// Equate all corresponding arguments</span></div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; lhsArgs.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;                    <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#af454c8b25ece926ca5206774d8f23be1">sub</a>.push_back(std::make_pair(lhsArgs[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>], rhsArgs[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>]));</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;                }</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160; </div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;                <span class="comment">// Get rid of the record equality</span></div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;                <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#af454c8b25ece926ca5206774d8f23be1">sub</a>.erase(<a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#af454c8b25ece926ca5206774d8f23be1">sub</a>.begin() + <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>);</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;                done = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((isA&lt;RecordInit&gt;(<a class="code" href="_resolve_aliases_8cpp.html#aa40661b6cade2b7755921bda0bac0fb4">lhs</a>) &amp;&amp; isA&lt;Constant&gt;(<a class="code" href="_resolve_aliases_8cpp.html#a4e09535c06791089b6e68d7af597db7a">rhs</a>)) ||</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;                       (isA&lt;Constant&gt;(<a class="code" href="_resolve_aliases_8cpp.html#aa40661b6cade2b7755921bda0bac0fb4">lhs</a>) &amp;&amp; isA&lt;RecordInit&gt;(<a class="code" href="_resolve_aliases_8cpp.html#a4e09535c06791089b6e68d7af597db7a">rhs</a>))) {</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;                <span class="comment">// A record =/= a constant</span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;            }</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;        }</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;    }</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160; </div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;}</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;<span class="comment"> * Returns the nullable vector of substitutions needed to unify the two given atoms.</span></div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;<span class="comment"> * If unification is not successful, the returned vector is marked as invalid.</span></div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;<span class="comment"> * Assumes that the atoms are both of the same relation.</span></div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;<span class="comment"> */</span></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="json11_8h_source.html#l00663">i</a>, <a class="el" href="_resolve_aliases_8cpp_source.html#l00184">lhs</a>, <a class="el" href="_resolve_aliases_8cpp_source.html#l00185">rhs</a>, and <a class="el" href="_constraint_system_8h_source.html#l00228">souffle::ast::analysis::sub()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_1_1ast_1_1transform_abfc33cde145c8603d71c83eed4672c1f_cgraph.png" border="0" usemap="#namespacesouffle_1_1ast_1_1transform_abfc33cde145c8603d71c83eed4672c1f_cgraph" alt=""/></div>
<map name="namespacesouffle_1_1ast_1_1transform_abfc33cde145c8603d71c83eed4672c1f_cgraph" id="namespacesouffle_1_1ast_1_1transform_abfc33cde145c8603d71c83eed4672c1f_cgraph">
<area shape="rect" title="Reduces a vector of substitutions." alt="" coords="5,5,172,47"/>
<area shape="rect" href="namespacesouffle_1_1ast_1_1analysis.html#af454c8b25ece926ca5206774d8f23be1" title="A generic factory for constraints of the form." alt="" coords="220,13,407,39"/>
</map>
</div>

</div>
</div>
<a id="a1211fcf1fa30273559973f585502c936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1211fcf1fa30273559973f585502c936">&#9670;&nbsp;</a></span>renameVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::ast::transform::renameVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renames all variables in a given argument uniquely. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00494">494</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;                      : varnum(varnum) {}</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;        Own&lt;Node&gt; operator()(Own&lt;Node&gt; node)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;            <span class="keywordflow">if</span> (<span class="keyword">auto</span>* var = <span class="keyword">dynamic_cast&lt;</span>ast::Variable*<span class="keyword">&gt;</span>(node.get())) {</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;                <span class="keyword">auto</span> newVar = <a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a>(var);</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;                std::stringstream newName;</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;                newName &lt;&lt; var-&gt;getName() &lt;&lt; <span class="stringliteral">&quot;-v&quot;</span> &lt;&lt; varnum;</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;                newVar-&gt;setName(newName.str());</div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;                <span class="keywordflow">return</span> newVar;</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;            }</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;            node-&gt;apply(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;            <span class="keywordflow">return</span> node;</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;        }</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;    };</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160; </div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;    M update(varCount);</div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;    arg-&gt;apply(update);</div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;}</div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160; </div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;<span class="comment">// Performs a given binary op on a list of aggregators recursively.</span></div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;<span class="comment">// E.g. ( &lt;aggr1, aggr2, aggr3, ...&gt;, o &gt; = (aggr1 o (aggr2 o (agg3 o (...))))</span></div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;<span class="comment">// TODO (azreika): remove aggregator support</span></div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;Argument* <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a82a6c6c43a0014cd5c333f52169e38ed">combineAggregators</a>(std::vector&lt;Aggregator*&gt; aggrs, std::string fun) {</div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;    <span class="comment">// Due to variable scoping issues with aggregators, we rename all variables uniquely in the</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a00b86d43c262e724277436f7f829a4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b86d43c262e724277436f7f829a4fb">&#9670;&nbsp;</a></span>transformEqrelRelation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::ast::transform::transformEqrelRelation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_relation.html">Relation</a> &amp;&#160;</td>
          <td class="paramname"><em>rel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform eqrel relations to explicitly define equivalence relations. </p>

<p class="definition">Definition at line <a class="el" href="_provenance_8cpp_source.html#l00203">203</a> of file <a class="el" href="_provenance_8cpp_source.html">Provenance.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;          {</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;Own&lt;Argument&gt; getNextLevelNumber(<span class="keyword">const</span> std::vector&lt;Argument*&gt;&amp; levels) {</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;    <span class="keywordflow">if</span> (levels.empty()) <span class="keywordflow">return</span> mk&lt;NumericConstant&gt;(0);</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160; </div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;    <span class="keyword">auto</span> max = levels.size() == 1</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4ef7394d84d020c597cb916fa67ff8ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef7394d84d020c597cb916fa67ff8ed">&#9670;&nbsp;</a></span>unifyAtoms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html">NullableVector</a>&lt;std::pair&lt;<a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a>*, <a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a>*&gt; &gt; souffle::ast::transform::unifyAtoms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_atom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_atom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the nullable vector of substitutions needed to unify the two given atoms. </p>
<p>If unification is not successful, the returned vector is marked as invalid. Assumes that the atoms are both of the same relation. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00278">278</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;                                                  {</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;        substitution.push_back(std::make_pair(firstArgs[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>], secondArgs[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>]));</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;    }</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160; </div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    <span class="comment">// Reduce the substitutions</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    <span class="keywordtype">bool</span> success = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#abfc33cde145c8603d71c83eed4672c1f">reduceSubstitution</a>(substitution);</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    <span class="keywordflow">if</span> (success) {</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;std::pair&lt;Argument*, Argument*&gt;&gt;(substitution);</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;        <span class="comment">// Failed to unify the two atoms</span></div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;std::pair&lt;Argument*, Argument*&gt;&gt;();</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;    }</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;}</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;<span class="comment"> * Inlines the given atom based on a given clause.</span></div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;<span class="comment"> * Returns the vector of replacement literals and the necessary constraints.</span></div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;<span class="comment"> * If unification is unsuccessful, the vector of literals is marked as invalid.</span></div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;<span class="comment"> */</span></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="json11_8h_source.html#l00663">i</a>.</p>

</div>
</div>
<a id="a8494f3003162a166742bb226a9e97d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8494f3003162a166742bb226a9e97d4a">&#9670;&nbsp;</a></span>usesInvalidWitness()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::vector&lt;<a class="el" href="classsouffle_1_1_src_location.html">SrcLocation</a>&gt; souffle::ast::transform::usesInvalidWitness </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_translation_unit.html">TranslationUnit</a> &amp;&#160;</td>
          <td class="paramname"><em>tu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;&#160;</td>
          <td class="paramname"><em>clause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_aggregator.html">Aggregator</a> &amp;&#160;</td>
          <td class="paramname"><em>aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A witness is considered "invalid" if it is trying to export a witness out of a count, sum, or mean aggregate. </p>
<p>However we need to be careful: Sometimes a witness variables occurs within the body of a count, sum, or mean aggregate, but this is valid, because the witness actually belongs to an inner min or max aggregate.</p>
<p>We just need to check that that witness only occurs on this level. </p>

<p class="definition">Definition at line <a class="el" href="_semantic_checker_8cpp_source.html#l00647">647</a> of file <a class="el" href="_semantic_checker_8cpp_source.html">SemanticChecker.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;                            : aggregate.getBodyLiterals()) {</div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;        aggregateSubclause-&gt;addToBody(<a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a>(lit));</div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;    }</div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;    <span class="keyword">struct </span>InnerAggregateMasker : <span class="keyword">public</span> NodeMapper {</div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;        <span class="keyword">mutable</span> <span class="keywordtype">int</span> numReplaced = 0;</div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;        Own&lt;Node&gt; operator()(Own&lt;Node&gt; node)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;            <span class="keywordflow">if</span> (isA&lt;Aggregator&gt;(node.get())) {</div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;                std::string newVariableName = <span class="stringliteral">&quot;+aggr_var_&quot;</span> + <a class="code" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a>(numReplaced++);</div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;                <span class="keywordflow">return</span> mk&lt;Variable&gt;(newVariableName);</div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;            }</div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;            node-&gt;apply(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;            <span class="keywordflow">return</span> node;</div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;        }</div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;    };</div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;    InnerAggregateMasker update;</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;    aggregateSubclause-&gt;apply(update);</div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160; </div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;    <span class="comment">// Find the witnesses of the original aggregate.</span></div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;    <span class="comment">// If we can find occurrences of the witness in</span></div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;    <span class="comment">// this masked version of the aggregate subclause,</span></div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;    <span class="comment">// AND the aggregate is a sum / count / mean (we know this because</span></div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;    <span class="comment">// of the early exit for a min/max aggregate)</span></div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;    <span class="comment">// then we have an invalid witness and we&#39;ll add the source location</span></div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;    <span class="comment">// of the variable to the invalidWitnessLocations vector.</span></div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;    <span class="keyword">auto</span> witnesses = <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#ac7dcac078836134ae4e1e59e4d3148e3">analysis::getWitnessVariables</a>(tu, clause, aggregate);</div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; witness : witnesses) {</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;        <a class="code" href="namespacesouffle_1_1ast.html#a0bf6b9bdf0a8866bd27dde18442ab43d">visitDepthFirst</a>(*aggregateSubclause, [&amp;](<span class="keyword">const</span> Variable&amp; var) {</div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;            <span class="keywordflow">if</span> (var.getName() == witness) {</div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;                invalidWitnessLocations.push_back(var.getSrcLoc());</div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;            }</div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;        });</div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;    }</div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;    <span class="keywordflow">return</span> invalidWitnessLocations;</div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;}</div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160; </div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;<span class="keywordtype">void</span> SemanticCheckerImpl::checkWitnessProblem() {</div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;    <span class="comment">// Check whether there is the use of a witness in</span></div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;    <span class="comment">// an aggregate where it doesn&#39;t make sense to use it, i.e.</span></div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;    <span class="comment">// count, sum, mean</span></div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;    <a class="code" href="namespacesouffle_1_1ast.html#a0bf6b9bdf0a8866bd27dde18442ab43d">visitDepthFirst</a>(program, [&amp;](<span class="keyword">const</span> Clause&amp; clause) {</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespacesouffle_1_1ast_html_a29de8c1720372f7c78dcfabe84767118"><div class="ttname"><a href="namespacesouffle_1_1ast.html#a29de8c1720372f7c78dcfabe84767118">souffle::ast::cloneHead</a></div><div class="ttdeci">Clause * cloneHead(const Clause *clause)</div><div class="ttdoc">Returns a clause which contains head of the given clause.</div><div class="ttdef"><b>Definition:</b> <a href="_utils_8cpp_source.html#l00254">Utils.cpp:254</a></div></div>
<div class="ttc" id="anamespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail_html_a876af6f91231ae4e7e7316f5402682dc"><div class="ttname"><a href="namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail.html#a876af6f91231ae4e7e7316f5402682dc">TCB_SPAN_NAMESPACE_NAME::detail::size</a></div><div class="ttdeci">constexpr auto size(const C &amp;c) -&gt; decltype(c.size())</div><div class="ttdef"><b>Definition:</b> <a href="span_8h_source.html#l00198">span.h:198</a></div></div>
<div class="ttc" id="a_misc_util_8h_html_a80064103b41e5e72405c38edf202af56"><div class="ttname"><a href="_misc_util_8h.html#a80064103b41e5e72405c38edf202af56">UNREACHABLE_BAD_CASE_ANALYSIS</a></div><div class="ttdeci">#define UNREACHABLE_BAD_CASE_ANALYSIS</div><div class="ttdef"><b>Definition:</b> <a href="_misc_util_8h_source.html#l00206">MiscUtil.h:206</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1transform_html_a1211fcf1fa30273559973f585502c936"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#a1211fcf1fa30273559973f585502c936">souffle::ast::transform::renameVariables</a></div><div class="ttdeci">void renameVariables(Argument *arg)</div><div class="ttdoc">Renames all variables in a given argument uniquely.</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00494">InlineRelations.cpp:494</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1transform_html_abfc33cde145c8603d71c83eed4672c1f"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#abfc33cde145c8603d71c83eed4672c1f">souffle::ast::transform::reduceSubstitution</a></div><div class="ttdeci">bool reduceSubstitution(std::vector&lt; std::pair&lt; Argument *, Argument * &gt;&gt; &amp;sub)</div><div class="ttdoc">Reduces a vector of substitutions.</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00219">InlineRelations.cpp:219</a></div></div>
<div class="ttc" id="anamespacetinyformat_html_adc3e74768f0e2204f9f9a726fc07ec61"><div class="ttname"><a href="namespacetinyformat.html#adc3e74768f0e2204f9f9a726fc07ec61">tinyformat::format</a></div><div class="ttdeci">void format(std::ostream &amp;out, const char *fmt)</div><div class="ttdef"><b>Definition:</b> <a href="tinyformat_8h_source.html#l01089">tinyformat.h:1089</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1analysis_html_af454c8b25ece926ca5206774d8f23be1"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#af454c8b25ece926ca5206774d8f23be1">souffle::ast::analysis::sub</a></div><div class="ttdeci">std::shared_ptr&lt; Constraint&lt; Var &gt; &gt; sub(const Var &amp;a, const Var &amp;b, const std::string &amp;symbol=&quot;&quot;)</div><div class="ttdoc">A generic factory for constraints of the form.</div><div class="ttdef"><b>Definition:</b> <a href="_constraint_system_8h_source.html#l00228">ConstraintSystem.h:228</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1transform_html_ae484a45044de39fe908c7877109f1f28"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#ae484a45044de39fe908c7877109f1f28">souffle::ast::transform::nameInlinedUnderscores</a></div><div class="ttdeci">bool nameInlinedUnderscores(Program &amp;program)</div><div class="ttdoc">Removes all underscores in all atoms of inlined relations.</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00146">InlineRelations.cpp:146</a></div></div>
<div class="ttc" id="anamespacesouffle_html_aa26a7e6147aca5568158e38f08ffcf21"><div class="ttname"><a href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21">souffle::AggregateOp</a></div><div class="ttdeci">AggregateOp</div><div class="ttdoc">Types of aggregation functions.</div><div class="ttdef"><b>Definition:</b> <a href="_aggregate_op_8h_source.html#l00034">AggregateOp.h:34</a></div></div>
<div class="ttc" id="anamespacesouffle_html_a10525539360588d9c9048cb27f80d6ea"><div class="ttname"><a href="namespacesouffle.html#a10525539360588d9c9048cb27f80d6ea">souffle::toBinaryConstraintSymbol</a></div><div class="ttdeci">char const  * toBinaryConstraintSymbol(const BinaryConstraintOp op)</div><div class="ttdoc">Converts operator to its symbolic representation.</div><div class="ttdef"><b>Definition:</b> <a href="_binary_constraint_ops_8h_source.html#l00336">BinaryConstraintOps.h:336</a></div></div>
<div class="ttc" id="a_resolve_aliases_8cpp_html_a4e09535c06791089b6e68d7af597db7a"><div class="ttname"><a href="_resolve_aliases_8cpp.html#a4e09535c06791089b6e68d7af597db7a">rhs</a></div><div class="ttdeci">Own&lt; Argument &gt; rhs</div><div class="ttdef"><b>Definition:</b> <a href="_resolve_aliases_8cpp_source.html#l00185">ResolveAliases.cpp:185</a></div></div>
<div class="ttc" id="ahtml_js_chartist_min_8h_html_aab858032a95af802114b255fac6f45f2"><div class="ttname"><a href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a></div><div class="ttdeci">var j</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="a_resolve_aliases_8cpp_html_aa40661b6cade2b7755921bda0bac0fb4"><div class="ttname"><a href="_resolve_aliases_8cpp.html#aa40661b6cade2b7755921bda0bac0fb4">lhs</a></div><div class="ttdeci">Own&lt; Argument &gt; lhs</div><div class="ttdef"><b>Definition:</b> <a href="_resolve_aliases_8cpp_source.html#l00184">ResolveAliases.cpp:184</a></div></div>
<div class="ttc" id="anamespacesouffle_html_aecc08c83ad9634fc515b7aa094702949"><div class="ttname"><a href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">souffle::toString</a></div><div class="ttdeci">const std::string &amp; toString(const std::string &amp;str)</div><div class="ttdoc">A generic function converting strings into strings (trivial case).</div><div class="ttdef"><b>Definition:</b> <a href="_string_util_8h_source.html#l00234">StringUtil.h:234</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1transform_html_a5ab750d18fe838e77f89370c6bf7d820"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#a5ab750d18fe838e77f89370c6bf7d820">souffle::ast::transform::findInlineCycle</a></div><div class="ttdeci">std::vector&lt; QualifiedName &gt; findInlineCycle(const PrecedenceGraphAnalysis &amp;precedenceGraph, std::map&lt; const Relation *, const Relation * &gt; &amp;origins, const Relation *current, RelationSet &amp;unvisited, RelationSet &amp;visiting, RelationSet &amp;visited)</div><div class="ttdoc">Find a cycle consisting entirely of inlined relations.</div><div class="ttdef"><b>Definition:</b> <a href="_semantic_checker_8cpp_source.html#l00713">SemanticChecker.cpp:713</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1transform_html_adc2b2e6f9ed8feb3adfbfbfe43b96dda"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#adc2b2e6f9ed8feb3adfbfbfe43b96dda">souffle::ast::transform::containsInlinedAtom</a></div><div class="ttdeci">bool containsInlinedAtom(const Program &amp;program, const Clause &amp;clause)</div><div class="ttdoc">Checks if a given clause contains an atom that should be inlined.</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00202">InlineRelations.cpp:202</a></div></div>
<div class="ttc" id="anamespacesouffle_html_adea839071e91666e99dedc870a42941c"><div class="ttname"><a href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a></div><div class="ttdeci">auto clone(const std::vector&lt; A * &gt; &amp;xs)</div><div class="ttdef"><b>Definition:</b> <a href="_container_util_8h_source.html#l00172">ContainerUtil.h:172</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1transform_html_a4ee21dc1693bea38bbc8cf4447f27012"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#a4ee21dc1693bea38bbc8cf4447f27012">souffle::ast::transform::combineNegatedLiterals</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; Literal * &gt; &gt; combineNegatedLiterals(std::vector&lt; std::vector&lt; Literal * &gt;&gt; litGroups)</div><div class="ttdoc">Return the negated version of a disjunction of conjunctions.</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00385">InlineRelations.cpp:385</a></div></div>
<div class="ttc" id="ajson11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00663">json11.h:663</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_html_af59ed6a7c649aec10999baea2f2c8b35"><div class="ttname"><a href="namespacesouffle_1_1ast.html#af59ed6a7c649aec10999baea2f2c8b35">souffle::ast::getRelation</a></div><div class="ttdeci">Relation * getRelation(const Program &amp;program, const QualifiedName &amp;name)</div><div class="ttdoc">Returns the relation with the given name in the program.</div><div class="ttdef"><b>Definition:</b> <a href="_utils_8cpp_source.html#l00101">Utils.cpp:101</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1transform_html_a0249ff1a6616f955f319df5ffdfaae41"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#a0249ff1a6616f955f319df5ffdfaae41">souffle::ast::transform::getInlinedClause</a></div><div class="ttdeci">std::vector&lt; Clause * &gt; getInlinedClause(Program &amp;program, const Clause &amp;clause)</div><div class="ttdoc">Returns a list of clauses that should replace the given clause after one step of inlining.</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00911">InlineRelations.cpp:911</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1transform_html_addbf430b3cb758d9345bb1ba0dd17efd"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#addbf430b3cb758d9345bb1ba0dd17efd">souffle::ast::transform::getInlinedAtom</a></div><div class="ttdeci">NullableVector&lt; Atom * &gt; getInlinedAtom(Program &amp;program, Atom &amp;atom)</div><div class="ttdoc">Returns a vector of atoms that should replace the given atom after one step of inlining.</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00729">InlineRelations.cpp:729</a></div></div>
<div class="ttc" id="anamespacesouffle_html_abe4e3f19879707216a2758b03f4e2deb"><div class="ttname"><a href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb">souffle::join</a></div><div class="ttdeci">detail::joined_sequence&lt; Iter, Printer &gt; join(const Iter &amp;a, const Iter &amp;b, const std::string &amp;sep, const Printer &amp;p)</div><div class="ttdoc">Creates an object to be forwarded to some output stream for printing sequences of elements interspers...</div><div class="ttdef"><b>Definition:</b> <a href="_stream_util_8h_source.html#l00175">StreamUtil.h:175</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1transform_html_a940bd55ad10e760454fb7af87c1c130d"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#a940bd55ad10e760454fb7af87c1c130d">souffle::ast::transform::negateLiteral</a></div><div class="ttdeci">Literal * negateLiteral(Literal *lit)</div><div class="ttdoc">Returns the negated version of a given literal.</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00365">InlineRelations.cpp:365</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1transform_html_a60d908235c9c6d168bdfb2098b55090e"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#a60d908235c9c6d168bdfb2098b55090e">souffle::ast::transform::getInlinedLiteral</a></div><div class="ttdeci">NullableVector&lt; std::vector&lt; Literal * &gt; &gt; getInlinedLiteral(Program &amp;, Literal *)</div><div class="ttdoc">Tries to perform a single step of inlining on the given literal.</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00785">InlineRelations.cpp:785</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_html_a91b7228545d71d053324a666e48a528c"><div class="ttname"><a href="namespacesouffle_1_1ast.html#a91b7228545d71d053324a666e48a528c">souffle::ast::RelationSet</a></div><div class="ttdeci">std::set&lt; const Relation *, NameComparison &gt; RelationSet</div><div class="ttdoc">Relation set.</div><div class="ttdef"><b>Definition:</b> <a href="ast_2_relation_8h_source.html#l00180">Relation.h:180</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_html_a4aa067ee069beebb52dff5ee7250fc5f"><div class="ttname"><a href="namespacesouffle_1_1ast.html#a4aa067ee069beebb52dff5ee7250fc5f">souffle::ast::getClauses</a></div><div class="ttdeci">std::vector&lt; Clause * &gt; getClauses(const Program &amp;program, const QualifiedName &amp;relationName)</div><div class="ttdoc">Returns a vector of clauses in the program describing the relation with the given name.</div><div class="ttdef"><b>Definition:</b> <a href="_utils_8cpp_source.html#l00077">Utils.cpp:77</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1transform_html_a00b86d43c262e724277436f7f829a4fb"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#a00b86d43c262e724277436f7f829a4fb">souffle::ast::transform::transformEqrelRelation</a></div><div class="ttdeci">void transformEqrelRelation(Program &amp;program, Relation &amp;rel)</div><div class="ttdoc">Transform eqrel relations to explicitly define equivalence relations.</div><div class="ttdef"><b>Definition:</b> <a href="_provenance_8cpp_source.html#l00203">Provenance.cpp:203</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1transform_html_a4ef7394d84d020c597cb916fa67ff8ed"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#a4ef7394d84d020c597cb916fa67ff8ed">souffle::ast::transform::unifyAtoms</a></div><div class="ttdeci">NullableVector&lt; std::pair&lt; Argument *, Argument * &gt; &gt; unifyAtoms(Atom *first, Atom *second)</div><div class="ttdoc">Returns the nullable vector of substitutions needed to unify the two given atoms.</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00278">InlineRelations.cpp:278</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1transform_html_aae013df7b43e604d0cbe81322c8a11dc"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#aae013df7b43e604d0cbe81322c8a11dc">souffle::ast::transform::makeRelationName</a></div><div class="ttdeci">QualifiedName makeRelationName(const QualifiedName &amp;orig, const std::string &amp;type, int num=-1)</div><div class="ttdoc">Helper functions.</div><div class="ttdef"><b>Definition:</b> <a href="_provenance_8cpp_source.html#l00068">Provenance.cpp:68</a></div></div>
<div class="ttc" id="anamespacesouffle_html_a315141918c39611929a694840f046fb5"><div class="ttname"><a href="namespacesouffle.html#a315141918c39611929a694840f046fb5">souffle::fatal</a></div><div class="ttdeci">void fatal(const char *format, const Args &amp;... args)</div><div class="ttdef"><b>Definition:</b> <a href="_misc_util_8h_source.html#l00198">MiscUtil.h:198</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_html_aa858fc1ad141e8a9dd2b806407c65116"><div class="ttname"><a href="namespacesouffle_1_1ast.html#aa858fc1ad141e8a9dd2b806407c65116">souffle::ast::negateConstraintInPlace</a></div><div class="ttdeci">void negateConstraintInPlace(Constraint &amp;constraint)</div><div class="ttdoc">Negate an ast constraint.</div><div class="ttdef"><b>Definition:</b> <a href="_utils_8cpp_source.html#l00297">Utils.cpp:297</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1transform_html_a8a7455cc2262cc907c15e6124ac6588a"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#a8a7455cc2262cc907c15e6124ac6588a">souffle::ast::transform::formNegatedLiterals</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; Literal * &gt; &gt; formNegatedLiterals(Program &amp;program, Atom *atom)</div><div class="ttdoc">Forms the bodies that will replace the negation of a given inlined atom.</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00440">InlineRelations.cpp:440</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_html_a0bf6b9bdf0a8866bd27dde18442ab43d"><div class="ttname"><a href="namespacesouffle_1_1ast.html#a0bf6b9bdf0a8866bd27dde18442ab43d">souffle::ast::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const Node &amp;root, Visitor&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="ast_2utility_2_visitor_8h_source.html#l00273">Visitor.h:273</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1transform_html_a3ce47150ce3942c816dc5d8286f3ee23"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#a3ce47150ce3942c816dc5d8286f3ee23">souffle::ast::transform::inlineBodyLiterals</a></div><div class="ttdeci">std::pair&lt; NullableVector&lt; Literal * &gt;, std::vector&lt; BinaryConstraint * &gt; &gt; inlineBodyLiterals(Atom *atom, Clause *atomInlineClause)</div><div class="ttdoc">Inlines the given atom based on a given clause.</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00304">InlineRelations.cpp:304</a></div></div>
<div class="ttc" id="a_tui_8h_html_afb01ff7ecf303cdcd8f713643f605b77"><div class="ttname"><a href="_tui_8h.html#afb01ff7ecf303cdcd8f713643f605b77">rel</a></div><div class="ttdeci">void rel(size_t limit, bool showLimit=true)</div><div class="ttdef"><b>Definition:</b> <a href="_tui_8h_source.html#l01086">Tui.h:1086</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1transform_html_a82a6c6c43a0014cd5c333f52169e38ed"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#a82a6c6c43a0014cd5c333f52169e38ed">souffle::ast::transform::combineAggregators</a></div><div class="ttdeci">Argument * combineAggregators(std::vector&lt; Aggregator * &gt; aggrs, std::string fun)</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00521">InlineRelations.cpp:521</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1analysis_html_ac7dcac078836134ae4e1e59e4d3148e3"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#ac7dcac078836134ae4e1e59e4d3148e3">souffle::ast::analysis::getWitnessVariables</a></div><div class="ttdeci">std::set&lt; std::string &gt; getWitnessVariables(const TranslationUnit &amp;tu, const Clause &amp;clause, const Aggregator &amp;aggregate)</div><div class="ttdoc">Computes the set of witness variables that are used in the aggregate A variable is a witness if it oc...</div><div class="ttdef"><b>Definition:</b> <a href="_aggregate_8cpp_source.html#l00075">Aggregate.cpp:75</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1transform_html_ac78e04494a4e67eb9ae63a399c99d92f"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f">souffle::ast::transform::getInlinedArgument</a></div><div class="ttdeci">NullableVector&lt; Argument * &gt; getInlinedArgument(Program &amp;program, const Argument *arg)</div><div class="ttdoc">Returns a vector of arguments that should replace the given argument after one step of inlining.</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00543">InlineRelations.cpp:543</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
